<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="https://ubermen5che.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://ubermen5che.github.io/" rel="alternate" type="text/html" /><updated>2021-08-24T18:45:29+09:00</updated><id>https://ubermen5che.github.io/feed.xml</id><title type="html">Ubermen5che’s Blog</title><subtitle>My first private blog</subtitle><author><name>YongJun Kwon</name><email>ubermen5ch1308@gmail.com</email></author><entry><title type="html">[Spirng]빈 생명주기 콜백</title><link href="https://ubermen5che.github.io/java/spring/spring-bean-lifecycle-callback/" rel="alternate" type="text/html" title="[Spirng]빈 생명주기 콜백" /><published>2021-08-21T00:00:00+09:00</published><updated>2021-08-21T00:00:00+09:00</updated><id>https://ubermen5che.github.io/java/spring/spring-bean-lifecycle-callback</id><content type="html" xml:base="https://ubermen5che.github.io/java/spring/spring-bean-lifecycle-callback/">&lt;p&gt;데이터베이스 커넥션 풀이나, 네트워크 소켓처럼 애플리케이션 시작 시점에 필요한 연결을 미리 해두고, 애플리케이션 종료 시점에 연결을 모두 종료하는 작업을 진행하려면, 객체의 초기화와 종료 작업이 필요하다. 이번 글에서는 스프링을 통해 이러한 초기화 작업과 종료 작업을 어떻게 진행하는지 예제로 알아보고자 한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;참고: 애플리케이션 시작 시점에 DB 커넥션 풀과 연결을 미리 해두는 이유는 애플리케이션 서버와 데이터베이스간의 연결 과정에서 시간이 소요되기 때문이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;예제-코드&quot;&gt;예제 코드&lt;/h2&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;NetworkClient&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;NetworkClient&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;생성자 호출, url = &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;connect&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;초기화 연결 메세지&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;setUrl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;url&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;connect&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;connect: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;call: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot; &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;message = &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;disconnect&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;close: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 예제코드는 Application server에서 외부DB에 연결을 하는 과정을 가상으로 시뮬레이션하는 과정을 나타낸다. 아래는 코드는 테스트 코드이다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BeanLifeCycleTest&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@Test&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;lifeCycleTest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;ConfigurableApplicationContext&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ac&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AnnotationConfigApplicationContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;LifeCycleConfig&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;NetworkClient&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;client&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ac&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getBean&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;NetworkClient&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;ac&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@Configuration&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LifeCycleConfig&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nd&quot;&gt;@Bean&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;NetworkClient&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;networkClient&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
            &lt;span class=&quot;nc&quot;&gt;NetworkClient&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;networkClient&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;NetworkClient&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;networkClient&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setUrl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://hello-spirng.dev&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;networkClient&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;실행해보면 다음과 같은 이상한 결과가 나온다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;생성자 호출, url &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; null
connect: null
call: null message &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 초기화 연결 메세지
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;생성자 부분을 보면 url정보 없이 connect가 호출되는 것을 확인할 수 있다. 이는 당연한 결과로 써 setUrl 메서드로 url를 설정해주어야만 url이 존재하게된다. 그런데 여기서 의문을 가질 수 있다. 왜냐하면 생성자를 호출할 때 url를 같이 넘겨주면 위와 같은 이상한 결과를 얻지는 않을텐데 왜 위와 같은 코드를 사용할까?&lt;/p&gt;

&lt;p&gt;이에 대한 답은 아래의 참고사항으로 적어두었으니 읽어보기를 권한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;스프링 빈은 간단하게 다음과 같은 라이플사이클을 가진다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;객체 생성 → 의존관계 주입&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;스프링 빈은 객체를 생성하고, 의존관계 주입이 다 끝난 다음에 필요한 데이터를 사용할 수 있는 준비가 완료된다. 따라서 &lt;strong&gt;초기화 작업은 의존관계 주입이 모두 완료되고 난 다음에 호출해야 한다.&lt;/strong&gt; (위의 예제를 보아도 그렇다는것을 알 수 있다) 그런데 개발자가 의존관계 주입이 모두 완료된 시점을 어떻게 알 수 있을까？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;스프링은 의존관계 주입이 완료되면 스프링 빈에게 콜백 메서드를 통해서 초기화 시점을 알려주는 다양한 기능을 제공한다.&lt;/strong&gt; 또한 스프링은 스프링 컨테이너가 종료되기 직전에 소멸 콜백을 준다. 따라서 안전하게 종료 작업을 진행할 수 있다. 다양한 기능이 어떤것이 있는지는 다음번에 알아보도록 하고 스프링 빈의 이벤트 라이프사이클에 대해 알아보자.&lt;/p&gt;

&lt;h3 id=&quot;스프링-빈의-이벤트-라이프사이클&quot;&gt;스프링 빈의 이벤트 라이프사이클&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;스프링 컨테이너 생성 → 스프링 빈 생성 → 의존관계 주입 → 초기화 콜백 → 사용 → 소멸전 콜백 → 스프링 종료&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;초기화 콜백&lt;/strong&gt; : 빈이 생성되고, 빈의 외존관계 주입이 완료된 후 호출&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;소멸전 콜백&lt;/strong&gt; : 빈이 소멸되기 직전에 호출&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;스프링은 다양한 방식으로 생명주기 콜백을 지원한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;참고:객체의 생성과 초기화를 분리하자&lt;/strong&gt;
생성자는 필수 정보(파라미터를)받고, 메모리를 할당해서 객체를 생성하는 책임을 가진다. 반면에 초기화는 이렇게 생성된 값들을 활용해서 외부 커넥션을 연결하는등 무거운 동작을 수행한다. 따라서 생성자 안에서 무거운 초기화 작업을 함께 하는 것 보다는 객체를 생성하는 부분과 초기화 하는 부분을 명확하게 나누는 것이 유지보수 관점에서 좋다. 물론 초기화 작업이 내부 값들만 약간 변경한느 정도로 단순한 경우에는 생성자에서 한번데 다 처리하는게 더 나을 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;참고: 싱글톤 빈들은 스프링 컨테이너가 종료될 때 싱글톤 빈들도 함께 종료되기 때문에 스프링 컨테이너가 종료되기 직전에 소멸전 콜백이 일어난다. 싱글톤 처럼 컨테이너의 시작과 종료까지 생존하는 빈도 있지만, 생명주기가 짧은 빈들도 있는데 이 빈들은 컨테이너와 무관하게 해당 빈이 종료되기 직전에 소멸전 콜백이 일어난다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;빈-생명주기-콜백-3가지-방법&quot;&gt;빈 생명주기 콜백 3가지 방법&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;인터페이스(InitializingBean, DisposableBean)&lt;/li&gt;
  &lt;li&gt;@Bean 설정 정보에 초기화 메서드, 종료 메서드 지정&lt;/li&gt;
  &lt;li&gt;@PostConstruct, @PreDestroy 애노테이션 지원&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;인터페이스initializingbean-disposablebean&quot;&gt;인터페이스(InitializingBean, DisposableBean)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;스프링 전용 인터페이스. 해당 코드가 스프링 전용 인터페이스에 의존한다.
    &lt;ul&gt;
      &lt;li&gt;implements를 통해 구현체 코드를 작성해 주어야한다.&lt;/li&gt;
      &lt;li&gt;따라서 초기화, 소멸 메서드의 이름을 변경할 수 없다.&lt;/li&gt;
      &lt;li&gt;내가 코드를 고칠 수 없는 외부 라이브러리에 적용할 수 없다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;인터페이스를 사용하는 초기화, 종료 방법은 스프링 초창기에 나온 방법들이고, 지금은 더 나은 방법들이 있어서 거의 사용하지 않는다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;bean-설정-정보에-초기화-메서드-종료-메서드-지정&quot;&gt;@Bean 설정 정보에 초기화 메서드, 종료 메서드 지정&lt;/h2&gt;

&lt;h3 id=&quot;특징&quot;&gt;특징&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;설정 정보에 @Bean(initMethod = “init”, destroyMethod = “close”)처럼 초기화, 소멸 메서드를 지정할 수 있다.&lt;/li&gt;
  &lt;li&gt;메서드 이름을 자유롭게 줄 수 있다.&lt;/li&gt;
  &lt;li&gt;스프링 빈이 스프링 코드에 의존하지 않는다.&lt;/li&gt;
  &lt;li&gt;코드가 아니라 설정 정보를 사용하기 때문에 코드를 고칠 수 없는 외부 라이브러리에도 초기화, 종료 메서드를 적용할 수 있다.
    &lt;ul&gt;
      &lt;li&gt;즉, 외부 라이브러리 자체에서 내부적으로 초기화, 종료에 대한 메서드를 가지고 있고 이에 해당하는 메서드 명을 설정정보로 넘겨주면 되는것이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;종료-메서드-추론&quot;&gt;종료 메서드 추론&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Bean destroyMethod&lt;/code&gt; 속성에는 아주 특별한 기능이 존재.&lt;/li&gt;
  &lt;li&gt;라이브러리 대부분 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;close&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shutdown&lt;/code&gt;이라는 이름의 종료 메서드를 사용한다.&lt;/li&gt;
  &lt;li&gt;@Bean의 destroyMethod는 기본값이 (inferred)으로 등록되어 있다.&lt;/li&gt;
  &lt;li&gt;이 추론 기능은 close, shutdown이라는 이름의 메서드를 자동적으로 호출해준다.&lt;/li&gt;
  &lt;li&gt;따라서 직접 스프링 빈으로 등록하면 종료 메서드는 따로 적어주지 않아도 잘 동작한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;postconstruct-predestroy-애노테이션-방법&quot;&gt;@PostConstruct, @PreDestroy 애노테이션 방법&lt;/h2&gt;

&lt;h2 id=&quot;예제-코드-1&quot;&gt;예제 코드&lt;/h2&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;javax.annotation.PostConstruct&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;javax.annotation.PreDestroy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;NetworkClient&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;NetworkClient&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;생성자 호출, url = &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;connect&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;초기화 연결 메세지&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;setUrl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;url&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;connect&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;connect: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;call: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot; &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;message = &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;disconnect&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;close: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@PostConstruct&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;NetworkClient.init&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;connect&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;초기화 연결 메세지&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@PreDestroy&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;NetworkClient.destroy&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;disconnect&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;특징-1&quot;&gt;특징&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;최신 스프링에서 가장 권장하는 방법.&lt;/li&gt;
  &lt;li&gt;애노테이션 하나만 붙이면 되므로 매우 편리.&lt;/li&gt;
  &lt;li&gt;패키지를 잘 보면 javax.annotation.PostConstruct이다. 스프링에 종속적인 기술이 아니라 JSR-250이라는 자바 표준이다. 따라서 스프링이 아닌 다른 컨테이너에서도 동작함.&lt;/li&gt;
  &lt;li&gt;컴포넌트 스캔과 잘 어울린다.&lt;/li&gt;
  &lt;li&gt;유일한 단점은 외부 라이브러리에는 적용하지 못한다는 것. 외부 라이브러리를 초기화, 종료 해야하면 @Bean의 기능을 사용하자.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>YongJun Kwon</name><email>ubermen5ch1308@gmail.com</email></author><category term="JAVA" /><category term="Spring" /><category term="Bean" /><category term="Bean Lifecycle" /><category term="Callback" /><summary type="html">데이터베이스 커넥션 풀이나, 네트워크 소켓처럼 애플리케이션 시작 시점에 필요한 연결을 미리 해두고, 애플리케이션 종료 시점에 연결을 모두 종료하는 작업을 진행하려면, 객체의 초기화와 종료 작업이 필요하다. 이번 글에서는 스프링을 통해 이러한 초기화 작업과 종료 작업을 어떻게 진행하는지 예제로 알아보고자 한다.</summary></entry><entry><title type="html">[JAVA] Binding</title><link href="https://ubermen5che.github.io/java/JAVA-Binding/" rel="alternate" type="text/html" title="[JAVA] Binding" /><published>2021-08-21T00:00:00+09:00</published><updated>2021-08-21T00:00:00+09:00</updated><id>https://ubermen5che.github.io/java/%5BJAVA%5DBinding</id><content type="html" xml:base="https://ubermen5che.github.io/java/JAVA-Binding/">&lt;h2 id=&quot;binding이란&quot;&gt;Binding이란&lt;/h2&gt;

&lt;p&gt;Method invocation과 method definition을 연관짓는 process.&lt;/p&gt;

&lt;h2 id=&quot;binding-종류&quot;&gt;Binding 종류&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Early binding : 컴파일 타임에 binding이 일어남.&lt;/li&gt;
  &lt;li&gt;Late binding : Run Time에 binding이  일어남.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;how-late-binding-works&quot;&gt;How late binding works?&lt;/h2&gt;

&lt;h3 id=&quot;note&quot;&gt;Note&lt;/h3&gt;

&lt;p&gt;설명하기 쉽도록 가정을 해보도록 하자. 우선 Figure라는 부모 클래스가 존재하고 자식클래스로는 Circle, Square, Triangle.. 여러 도형이 있을 수 있다고 가정한다. 그리고 Figure 클래스에는 center라고 하는 메서드 하나를 가지는데 화면상에서 좌표를 바꾸어 도형을 다시 그려주는 기능을 한다. 자식클래스에서는 draw메서드가 존재하는데 현재 가진 도형정보를 토대로 화면상에 그려주는 기능을 한다.&lt;/p&gt;

&lt;h3 id=&quot;시나리오&quot;&gt;시나리오&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Rectangle&lt;/code&gt; 그리고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Circle&lt;/code&gt;과 같은 클래스에서 상속받은 메서드 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;center()&lt;/code&gt;를 사용한다고 생각해볼 때 다형성에 대해 자세히 모른다면 의아해 할 수 있는 상황이 발생한다.&lt;/p&gt;

&lt;p&gt;부모클래스에서 정의된 메서드 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;center()&lt;/code&gt;는 내부적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;draw()&lt;/code&gt; 를 사용한다. 그리고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;draw()&lt;/code&gt;는 자식 클래스에 따라 코드가 전부 다르다. 만약 JAVA에서 late binding을 사용하지 않고 &lt;strong&gt;early binding&lt;/strong&gt;을 사용한다면 어떻게 될까?&lt;/p&gt;

&lt;p&gt;우선 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;center()&lt;/code&gt;은 부모클래스에 정의 되어있다. 이것이 의미하는 바는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;draw()&lt;/code&gt; code를 작성하기 전에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;center()&lt;/code&gt;는 이미 컴파일이 되어있다고 봐도 무방하다. 문제가 되는 부분은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;draw()&lt;/code&gt;일 것이다. 위에서 설명했듯이 자식 클래스 별로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;draw()&lt;/code&gt;는 코드가 모두 다르기 때문이다.&lt;/p&gt;

&lt;p&gt;early binding이 적용되면 현재 이용가능한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;draw()&lt;/code&gt;의 정의로 고정될 수 밖에 없다. 따라서 모든 자식클래스의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;draw()&lt;/code&gt;는 컴파일시에 이용된 method definition으로 고정되어 버리기 때문에 같은 동작을 수행할 수 밖에 없다. 반면 &lt;strong&gt;lateing binding&lt;/strong&gt;을 사용한다면 함수 호출이 발생할 때 binding이 이루어 지기 때문에 각 클래스에 따른 적합한 method definition이 연관되어 올바른 연산이 가능해진다.&lt;/p&gt;

&lt;h2 id=&quot;덧붙이자면&quot;&gt;덧붙이자면…&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Polymorphism&lt;/em&gt;&lt;/strong&gt;과 &lt;em&gt;late binding&lt;/em&gt;은 근본적으로 같은 개념을 나타내는 용어이다. &lt;em&gt;Polymorphism&lt;/em&gt;은 &lt;em&gt;late binding&lt;/em&gt;을 사용하여 하나의 메소드 이름에 다양한 의미를 부여하는 process를 지칭한다.&lt;/p&gt;</content><author><name>YongJun Kwon</name><email>ubermen5ch1308@gmail.com</email></author><category term="JAVA" /><category term="Binding" /><category term="Late binding" /><category term="Early binding" /><category term="Dynamic binding" /><category term="Polymorphism" /><summary type="html">Binding이란</summary></entry><entry><title type="html">[Spring] 다양한 의존관계 주입 방법</title><link href="https://ubermen5che.github.io/spring/Spring-%EB%8B%A4%EC%96%91%ED%95%9C-%EC%9D%98%EC%A1%B4%EA%B4%80%EA%B3%84-%EC%A3%BC%EC%9E%85-%EB%B0%A9%EB%B2%95/" rel="alternate" type="text/html" title="[Spring] 다양한 의존관계 주입 방법" /><published>2021-08-12T00:00:00+09:00</published><updated>2021-08-12T00:00:00+09:00</updated><id>https://ubermen5che.github.io/spring/%5BSpring%5D%EB%8B%A4%EC%96%91%ED%95%9C%20%EC%9D%98%EC%A1%B4%EA%B4%80%EA%B3%84%20%EC%A3%BC%EC%9E%85%20%EB%B0%A9%EB%B2%95</id><content type="html" xml:base="https://ubermen5che.github.io/spring/Spring-%EB%8B%A4%EC%96%91%ED%95%9C-%EC%9D%98%EC%A1%B4%EA%B4%80%EA%B3%84-%EC%A3%BC%EC%9E%85-%EB%B0%A9%EB%B2%95/">&lt;h2 id=&quot;의존관계-주입은-크게-4가지-방법이-있다&quot;&gt;의존관계 주입은 크게 4가지 방법이 있다&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;생성자 주입&lt;/li&gt;
  &lt;li&gt;수정자 주입(setter 주입)&lt;/li&gt;
  &lt;li&gt;필드 주입&lt;/li&gt;
  &lt;li&gt;일반 메서드 주입&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;생성자-주입&quot;&gt;생성자 주입&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;생성자를 통해서 의존 관계를 주입 받는 방법이다.&lt;/li&gt;
  &lt;li&gt;특징
    &lt;ul&gt;
      &lt;li&gt;생성자 호출시점에서 딱 1번만 호출되는 것이 보장된다.&lt;/li&gt;
      &lt;li&gt;불편, 필수 의존관계에 사용
        &lt;ul&gt;
          &lt;li&gt;ex) MVC패턴에서 Repository, Service등과 같이 필수적으로 사용되는 객체들&lt;/li&gt;
          &lt;li&gt;거의 대부분의 서비스에서 생성자 주입방법을 사용한다.&lt;/li&gt;
          &lt;li&gt;왜냐하면 웹 서비스를 공연으로 비유할 수 있는데, 공연이 진행되는 도중에 배우를 바꾸는 경우는 잘 없기 때문이다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Component&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;OrderServiceImpl&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;OrderService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MemberRepository&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memberRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DiscountPolicy&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;discountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@Autowired&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;OrderServiceImpl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;MemberRepository&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memberRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DiscountPolicy&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rateDiscountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;memberRepository&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memberRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;discountPolicy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rateDiscountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;⭐️ &lt;strong&gt;생성자가 딱 1개만 있으면 @Autowired를 생략해도 자동 주입된다.(물론 스프링 빈에만 해당)&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;수정자-주입setter-주입_&quot;&gt;수정자 주입(setter 주입_&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;setter라 불리는 필드의 값을 변경하는 수정자 메서드를 통해서 의존관계를 주입하는 방법.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;특징&quot;&gt;특징&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;선택, 변경 가능성이 있는 의존관계에 사용&lt;/li&gt;
  &lt;li&gt;자바빈 프로퍼티 규약의 setter 메서드 방식을 사용하는 방법.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Component&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;OrderServiceImpl&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;OrderService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MemberRepository&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memberRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DiscountPolicy&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;discountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

		&lt;span class=&quot;nd&quot;&gt;@Autowired&lt;/span&gt;
		&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;setMemberRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;MemberRepository&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memberRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;memberRepository&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memberRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

		&lt;span class=&quot;nd&quot;&gt;@Autowired&lt;/span&gt;
		&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;setDiscountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;DiscountPolicy&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;discountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;discountPolicy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;discountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;참고: @Autowired의 기본 동작은 스프링 컨테이너에서 해당 빈을 탐색하고 탐색결과 주입할 대상이 없으면 오류가 발생한다. 주입할 대상이 없어도 동작하게 할려면 @Autowired(required = false)로 지정하면 된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;필드-주입&quot;&gt;필드 주입&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;필드에 바로 의존관계를 주입하는 방법.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;특징-1&quot;&gt;특징&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;코드가 간결해서 많은 개발자들을 유혹하지만 외부에서 변경이 불가능해서 테스트 하기 힘들다는 치명적인 단점이 존재.&lt;/li&gt;
  &lt;li&gt;DI 프레임워크가 없으면 아무것도 할 수 없다.&lt;/li&gt;
  &lt;li&gt;사용하지 않는것이 좋지만 예외적으로 사용함.
    &lt;ul&gt;
      &lt;li&gt;애플리케이션의 실제 코드와 관계 없는 테스트 코드&lt;/li&gt;
      &lt;li&gt;스프링 설정을 목적으로 하는 @Configuration 같은 곳에서만 특별한 용도로 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Component&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;OrderServiceImpl&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;OrderService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

		&lt;span class=&quot;nd&quot;&gt;@Autowired&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MemberRepository&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memberRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;nd&quot;&gt;@Autowired&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DiscountPolicy&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;discountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;참고: 순수한 자바 테스트 코드에는 당연히 @Autowired가 동작하지 않는다. @SpringBootTest처럼 스프링 컨테이너를 테스트에 통합한 경우에만 사용가능.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;다음 코드와 같이 @Bean에서 파라미터에 의존관계는 자동 주입된다. 수동 등록시 자동 등록된 빈의 의존관계가 필요할 때 문제를 해결할 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Bean&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;OrderService&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;orderService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;MemberRepository&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memberRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DiscountPolicy&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;discountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;OrderServiceImpl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memberRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;discountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;일반-메서드-주입&quot;&gt;일반 메서드 주입&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;일반 메서드를 통해서 주입 받을 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;특징-2&quot;&gt;특징&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;한번에 여러 필드를 주입 받을 수 있다.&lt;/li&gt;
  &lt;li&gt;일반적으로 잘 사용하지 않는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Component&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;OrderServiceImpl&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;OrderService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MemberRepository&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memberRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DiscountPolicy&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;discountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@Autowired&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;MemberRepository&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memberRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DiscountPolicy&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rateDiscountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;memberRepository&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memberRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;discountPolicy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rateDiscountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>YongJun Kwon</name><email>ubermen5ch1308@gmail.com</email></author><category term="Spring" /><category term="Spring" /><category term="DI" /><summary type="html">의존관계 주입은 크게 4가지 방법이 있다</summary></entry><entry><title type="html">[JAVA] Privacy Leaks</title><link href="https://ubermen5che.github.io/java/spring/JAVA-Privacy-Leaks/" rel="alternate" type="text/html" title="[JAVA] Privacy Leaks" /><published>2021-08-07T00:00:00+09:00</published><updated>2021-08-07T00:00:00+09:00</updated><id>https://ubermen5che.github.io/java/spring/%5BJAVA%5DPrivacy%20Leaks</id><content type="html" xml:base="https://ubermen5che.github.io/java/spring/JAVA-Privacy-Leaks/">&lt;p&gt;클래스를 정의할 때 외부에서 접근하지 못하도록 instance variables를 private로 둔다. 그러나 private로 설정한다고 해서 privacy leaks을 막을 수 없다. 클래스를 잘못 설계하면 private으로 설정한 instance variable도 값이 변경될 수 있기 때문이다.&lt;/p&gt;

&lt;h1 id=&quot;잘못-설계된-클래스-예&quot;&gt;잘못 설계된 클래스 예&lt;/h1&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;

	&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Date&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;born&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Date&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;died&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;//생성자&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;//setter&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;//getter&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Date&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getBirthDate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;born&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;//...&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;consistent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Date&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;birthDate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Date&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;deathDate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;birthDate&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;deathDate&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
			&lt;span class=&quot;nf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;birthDate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;precedes&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;deathDate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;birthDate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;deathDate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;위의 예에서 getBirthDate method를 살펴보자.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;해당 메소드는 단지 &lt;strong&gt;born&lt;/strong&gt;이라는 인스턴스 변수를 return하고 있다. 이론적으로 born의 레퍼런스를 return하기 때문에 어딘가 다른 class에서 아래와 같이 코드를 작성하게되면 Person클래스 내부에서 분명 private으로 &lt;strong&gt;born&lt;/strong&gt;을 설정하였지만 &lt;strong&gt;getBirthDate&lt;/strong&gt; 메소드를 통해 리턴받은 Date type 레퍼런스에 의해 &lt;strong&gt;setYear&lt;/strong&gt;메소드를 사용할 수 있게 되었고 그에 따라 결국 private로 선언된 &lt;strong&gt;born&lt;/strong&gt;의 인스턴스 변수의 값이 변경될 수 있음을 보여준다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//Date class에는 instance variable로 String month, int day, int year 존재.&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//모두 private으로 설정하였고, getter, setter 존재.&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;person&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(...);&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;Date&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bornDate&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;person&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getBirthDate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;bornDate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setYear&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그러나 이러한 걱정은 자바에 의해 덜 수 있다. 자바는 private로 선언된 instance varialbes에 대해 내부적으로 clone하여 return해주기 때문에 위의 예시같은 일은 발생하지 않는다. 하지만 레퍼런스를 리턴하는 경우 뿐만 아니고 다른 privacy leaks을 발생시킬 수 있는 상황들이 존재하는데, 이상하게 정의된 생성자와 setter가 존재할 때 발생한다. 아래의 예시를 살펴보자.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//Person class내부에 정의된 메소드&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//consistent 메소드는 Person class내부에 정의된 static method로 올바른 입력인지 검사한다.&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;setBirthDate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Date&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newDate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;consistent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;newDate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;died&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;born&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newDate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;//에러메세지 출력&lt;/span&gt;
		&lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위와 같은 메소드가 있다고 했을 때 아래의 코드를 실행한다면?&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;personObject&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Josephine&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
				&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Date&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;January&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;Date&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dateName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Date&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Feburuary&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2002&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;personObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setBirthDate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dateName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;dateName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setYear&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//문제 발생&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;personObject&lt;/strong&gt;의 instance variable인 &lt;strong&gt;born&lt;/strong&gt;에 클래스 타입이 &lt;strong&gt;Date&lt;/strong&gt;인 &lt;strong&gt;object(dateName)&lt;/strong&gt;의 레퍼런스가 들어가게된다. 따라서 &lt;strong&gt;dateName.setYear(1000)&lt;/strong&gt;과 같이 메소드를 실행할 수 있게되고 이렇게되면 &lt;strong&gt;Person&lt;/strong&gt;의 &lt;strong&gt;setBirthDate&lt;/strong&gt;의 &lt;strong&gt;consistent&lt;/strong&gt;메소드를 거치지 않으므로 유효하지 않은 입력이 들어갈 수 있게될 뿐만 아니라 instance variable가 예기치 못하게 변경될 수 있는 문제점이 발생한다. 이를 해결하기 위해서는 아래와 같이 아주 조금만 코드 변경을 해주면 된다~&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;setBirthDate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Date&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newDate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;consistent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;newDate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;died&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;born&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Date&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;newDate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;//코드 수정&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;스프링에서는&quot;&gt;스프링에서는&lt;/h1&gt;

&lt;p&gt;Privacy Leaks을 공부하면서 의문이 들었다. 스프링에서는 아래와 같은 코드를 자주 접할 수 있었다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Autowired&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;MemberServiceImpl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;MemberRepository&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memberRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;memberRepository&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memberRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그러나 분명 위와 같이 코드를 짜면 privacy leaks이 발생하는것이 아닌가 하는 의문이 생겼다.&lt;/p&gt;

&lt;p&gt;스프링 빈은 싱글톤으로 관리된다고 하였는데 이를 상기해보면 당연한 이치라고 생각된다. 왜냐하면 하나의 객체만 생성해서 공유하기 때문에 privacy leak이 발생할 수 밖에 없는 구조인것이다. 그러나 실제로는 무상태로 싱글톤을 설계한다면 privacy leak이 발생하지 않는 방향으로 갈 수 있지 않을까 생각한다…&lt;/p&gt;</content><author><name>YongJun Kwon</name><email>ubermen5ch1308@gmail.com</email></author><category term="JAVA" /><category term="Spring" /><category term="private" /><category term="JAVA" /><category term="Spring" /><summary type="html">클래스를 정의할 때 외부에서 접근하지 못하도록 instance variables를 private로 둔다. 그러나 private로 설정한다고 해서 privacy leaks을 막을 수 없다. 클래스를 잘못 설계하면 private으로 설정한 instance variable도 값이 변경될 수 있기 때문이다.</summary></entry><entry><title type="html">[컨트리뷰톤] Git/GitHub 기본실습-2</title><link href="https://ubermen5che.github.io/git/%EB%8C%80%EC%99%B8%20%ED%99%9C%EB%8F%99/%EC%BB%A8%ED%8A%B8%EB%A6%AC%EB%B7%B0%ED%86%A4-Git-%EA%B8%B0%EB%B3%B8%EC%8B%A4%EC%8A%B5-2/" rel="alternate" type="text/html" title="[컨트리뷰톤] Git/GitHub 기본실습-2" /><published>2021-08-06T00:00:00+09:00</published><updated>2021-08-06T00:00:00+09:00</updated><id>https://ubermen5che.github.io/git/%EB%8C%80%EC%99%B8%20%ED%99%9C%EB%8F%99/%5B%EC%BB%A8%ED%8A%B8%EB%A6%AC%EB%B7%B0%ED%86%A4%5DGit%20%EA%B8%B0%EB%B3%B8%EC%8B%A4%EC%8A%B5-2</id><content type="html" xml:base="https://ubermen5che.github.io/git/%EB%8C%80%EC%99%B8%20%ED%99%9C%EB%8F%99/%EC%BB%A8%ED%8A%B8%EB%A6%AC%EB%B7%B0%ED%86%A4-Git-%EA%B8%B0%EB%B3%B8%EC%8B%A4%EC%8A%B5-2/">&lt;h1 id=&quot;오픈소스-개발참여를-위한-commit-작업branch--commit&quot;&gt;오픈소스 개발참여를 위한 commit 작업(branch &amp;amp; commit)&lt;/h1&gt;

&lt;h2 id=&quot;branch란&quot;&gt;Branch란?&lt;/h2&gt;

&lt;p&gt;브랜치는 다음과 같은 표현으로 간결하게 설명할 수 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“같은 폴더 다른세상”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;아래의 터미널을 보면  check-fosslight branch에서 hi.txt를 생성하고 commit을 한것을 볼 수 있다. 해당 브랜치에서 생성하고 commit한 파일을 main branch에서 찾아볼 수 있을까? 지난 포스팅에서 배운 git log 명령어를 이용하여 commit내역을 보면 확실하게 알 수 있을것이다!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/2021-08-06/branch.png&quot; alt=&quot;branch.png&quot; class=&quot;align-center&quot; width=&quot;100%&amp;quot;, height=&amp;quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;image-caption&quot;&gt;&lt;em&gt;그림1(main외에 브랜치에서 hi.txt생성)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;파이프라인을 명령어를 사용하여 HEAD -1을 하면 가장 상위 1개의 commit내역을 가져올 수 있다.&lt;/p&gt;

&lt;p&gt;아래의 사진을 통해 결과를 확인해보자. check-fosslight branch에는 hi.txt파일을 추가한 commit내역을 확인할 수 있다. &lt;strong&gt;그러나 main branch에서는 확인할 수 없었다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;즉, &lt;strong&gt;같은 폴더 다른세상&lt;/strong&gt;이라는 표현이 아주 적절한 표현임을 알 수 있었다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git log &lt;span class=&quot;nt&quot;&gt;--oneline&lt;/span&gt; | HEAD &lt;span class=&quot;nt&quot;&gt;-1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/2021-08-06/checkout.png&quot; alt=&quot;checkout.png&quot; class=&quot;align-center&quot; width=&quot;100%&amp;quot;, height=&amp;quot;100%&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;브랜치-관련-명령어-모음&quot;&gt;브랜치 관련 명령어 모음&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;브랜치 생성&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git checkout &lt;span class=&quot;nt&quot;&gt;-b&lt;/span&gt; &amp;lt;브랜치 이름&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;브랜치 삭제&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#삭제하고자 하는 브랜치로 이동&lt;/span&gt;
git checkout &amp;lt;브랜치 이름&amp;gt;
git branch &lt;span class=&quot;nt&quot;&gt;-D&lt;/span&gt; &amp;lt;브랜치 이름&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;현재 프랜치 확인 및 소스파일 상태확인&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git status
On branch main
Your branch is up to &lt;span class=&quot;nb&quot;&gt;date &lt;/span&gt;with &lt;span class=&quot;s1&quot;&gt;'origin/main'&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;

nothing to commit, working tree clean
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;현재는 nothing to commit(수정내역이 없음)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;소스파일-수정-후-최신역사와의-차이점-확인&quot;&gt;소스파일 수정 후 최신역사와의 차이점 확인&lt;/h2&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#소스파일 수정 확인 명령어&lt;/span&gt;
git diff
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;아래의 사진을 보면 빨간색으로 표시된 부분은 이전 역사와 달리 코드가 삭제된 부분을 나타내고, 초록색으로 나타는 부분은 새롭게 추가된 코드를 보여준다. 코드를 수정하고 commit하기 전에 이전과 달리 어느부분을 수정했는지 한눈에 파악하기 쉽게 만들어주는점에서 아주 유용한 명령어인것 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/2021-08-06/git_diff.png&quot; alt=&quot;git_diff.png&quot; class=&quot;align-center&quot; width=&quot;100%&amp;quot;, height=&amp;quot;100%&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;stash와-checkout&quot;&gt;stash와 checkout&lt;/h2&gt;

&lt;h3 id=&quot;stash&quot;&gt;Stash&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;임시저장소에 현재까지의 변경사항을 넣어두자!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git stash
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;stash를 설명하기에 앞서 stash를 적용해볼 수 있는 적절한 시나리오를 생각해보자.&lt;/p&gt;

&lt;p&gt;현재 내가 프로젝트내에 어떤 부분에 버그를 수정하기 위해 소스코드를 수정하였지만  commit으로 만들기는 아직 많은 테스트가 필요하기때문에 애매하고 버그 수정전과 후를 비교해보고싶은 경우라고 가정해보자. 이 때 적절하게 사용할 수 있는 명령어가 stash이다. stash를 이용하면 수정한 코드들을 임시 저장함으로써 수정전의 상태로 돌아갈 수 있다. 다시 버그 수정후의 역사로 돌아가고싶다면 임시저장한 코드를 stash pop을 이용해서 원래상태로 돌아갈 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git stash pop
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/2021-08-06/stash.png&quot; alt=&quot;stash.png&quot; class=&quot;align-center&quot; width=&quot;100%&amp;quot;, height=&amp;quot;100%&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;checkout&quot;&gt;Checkout&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;.git에 저장되어 있는 최신역사를 꺼낸다!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git checkout &lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt; &amp;lt;특정 파일&amp;gt;
&lt;span class=&quot;c&quot;&gt;#ex) git checkout -- README.md&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;checkout은 clone받은 프로젝트 폴더내에 숨김파일로 존재하는 .git폴더에 저장되어 있는(가장 최근 프로젝트 정보를 지니고있다) 프로젝트 log를 꺼내오는 명령어이다. 코드를 수정하다가 도저히 해결하기 어려운 버그를 오류를 만났을 때 깔끔하게 예전상태로 돌아가고싶다면 checkout만한 명령어가 없을것이다. 가장 최근의 기준 프로젝트 로그를 가지고있기 때문에 그냥 .git에서 꺼내오고 복구시키면 그만이기 때문이다.(undo 역할을 함) 브랜치를 변경할 때도 checkout을 사용한다. 같은 맥락으로 .git에 브랜치 정보가 저장되어있어 이것을 꺼내오는것이다.&lt;/p&gt;

&lt;h2 id=&quot;add-명령-취소-및-commit-삭제-명령어&quot;&gt;Add 명령 취소 및 commit 삭제 명령어&lt;/h2&gt;

&lt;h3 id=&quot;add-취소&quot;&gt;Add 취소&lt;/h3&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git reset
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;commit-취소-명령어&quot;&gt;Commit 취소 명령어&lt;/h3&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#HEAD~1은 가장 위에서 첫번째 내용을 삭제한다는 의미&lt;/span&gt;
git reset &lt;span class=&quot;nt&quot;&gt;--hard&lt;/span&gt; HEAD~1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;hard, soft 옵션의 차이점&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;hard의 경우 commit 내역 및 정보를 모두 삭제함&lt;/li&gt;
  &lt;li&gt;soft는 커밋 내역만 삭제하고 코드 변화분은 그대로 남음
    &lt;ul&gt;
      &lt;li&gt;여러개의 commit을 합칠때 유용하게 사용됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;commit-수정-명령어&quot;&gt;Commit 수정 명령어&lt;/h3&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git commit &lt;span class=&quot;nt&quot;&gt;--amend&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;ammend를 사용하여 commit message를 수정할 수 있다. 아래 사진을 자세히 보면 commit ID가 변경된것을 볼 수 있다. 이전 파일 정보가 하나라도 변경됐을경우 commit ID는 변경이 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/2021-08-06/before_ammend.png&quot; alt=&quot;before_ammend.png&quot; class=&quot;align-center&quot; width=&quot;100%&amp;quot;, height=&amp;quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;image-caption&quot;&gt;&lt;em&gt;ammend 전&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/2021-08-06/after_ammend.png&quot; alt=&quot;after_ammend.png&quot; class=&quot;align-center&quot; width=&quot;100%&amp;quot;, height=&amp;quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;image-caption&quot;&gt;&lt;em&gt;ammend 후&lt;/em&gt;&lt;/p&gt;

&lt;p class=&quot;notice--primary&quot;&gt;&lt;strong&gt;Primary Notice:&lt;/strong&gt; 해당 포스트는 리얼리눅스 송태웅님의 강의를 보고 정리한 내용임을 알립니다.&lt;/p&gt;</content><author><name>YongJun Kwon</name><email>ubermen5ch1308@gmail.com</email></author><category term="Git" /><category term="대외 활동" /><category term="Git/Github" /><category term="git 명령어" /><category term="rebase" /><category term="오픈소스" /><category term="branch" /><summary type="html">오픈소스 개발참여를 위한 commit 작업(branch &amp;amp; commit)</summary></entry><entry><title type="html">[컨트리뷰톤] 오픈소스 협업을 위한 Git/Github 고급과정-1</title><link href="https://ubermen5che.github.io/git/%EB%8C%80%EC%99%B8%20%ED%99%9C%EB%8F%99/%EC%BB%A8%ED%8A%B8%EB%A6%AC%EB%B7%B0%ED%86%A4-Git-%EA%B3%A0%EA%B8%89%EC%8B%A4%EC%8A%B5-1/" rel="alternate" type="text/html" title="[컨트리뷰톤] 오픈소스 협업을 위한 Git/Github 고급과정-1" /><published>2021-08-01T00:00:00+09:00</published><updated>2021-08-01T00:00:00+09:00</updated><id>https://ubermen5che.github.io/git/%EB%8C%80%EC%99%B8%20%ED%99%9C%EB%8F%99/%5B%EC%BB%A8%ED%8A%B8%EB%A6%AC%EB%B7%B0%ED%86%A4%5DGit%20%EA%B3%A0%EA%B8%89%EC%8B%A4%EC%8A%B5-1</id><content type="html" xml:base="https://ubermen5che.github.io/git/%EB%8C%80%EC%99%B8%20%ED%99%9C%EB%8F%99/%EC%BB%A8%ED%8A%B8%EB%A6%AC%EB%B7%B0%ED%86%A4-Git-%EA%B3%A0%EA%B8%89%EC%8B%A4%EC%8A%B5-1/">&lt;h1 id=&quot;rebase의-필요성&quot;&gt;Rebase의 필요성&lt;/h1&gt;

&lt;p&gt;평소 개인프로젝트를 할때 당연히 혼자만 commit을 하게된다. 또한 학교에서 팀프로젝트를 하게되는 경우 다수의 팀원들과 git을 이용하여 프로젝트를 진행하지만 모두가 push권한을 가지고 하는경우가 많은것 같다. 이는 협업이 아니며 분업이라고 해야할 것이다. 오픈소스 프로젝트 특성상 다수의 사람이 PR을 날리게 된다.&lt;/p&gt;

&lt;p&gt;만약 내가 수정하고 있는 모듈과 다른사람이 수정한 모듈에 연관관계가 있는경우, 내가 PR한것 말고 다른 contributor가 날린 PR이 먼저 merge된다면 내가 fork한 프로젝트는 예전 base(이전 commit 목록)가 되기때문에 충돌이 발생한다. 이때 필요한것이 rebase인데 충돌이 어떻게 해결되는지 원리를 이해하기 위해서는 rebase 명령어에 대한 자세한 사항을 알아둘 필요가 있다. 우선 rewind에 대해 알아보자.&lt;/p&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;commit-과거-시점으로-되감기rewind&quot;&gt;Commit 과거 시점으로 되감기(rewind)&lt;/h1&gt;

&lt;p&gt;아래 명령어는 commit을 과거 시점으로 되감기위해 사용하는 명령어이다. -i 옵션은 interactive를 의미한다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git rebase &lt;span class=&quot;nt&quot;&gt;-i&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--root&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;아래 그림은 명령어의 결과를 보여준다. 자세히 보면 commit ID와 commit message가 보이는데 여기서 주의해야할점은 git log 명령어의 순서와는 반대인것이다. git log는 가장 최근 commit이 상단에 위치하는데 반해서 rebase명령어는 가장 오래된 commit을 최상단에 보여준다. 그림1과 그림2를 보면 정말로 그런것을 볼 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/2021-08-01/rebase_i.png&quot; alt=&quot;rebase_i.png&quot; class=&quot;align-center&quot; width=&quot;100%&amp;quot;, height=&amp;quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;image-caption&quot;&gt;&lt;em&gt;그림1(rebase -i)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/2021-08-01/git_log.png&quot; alt=&quot;git_log.png&quot; class=&quot;align-center&quot; width=&quot;100%&amp;quot;, height=&amp;quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;image-caption&quot;&gt;&lt;em&gt;그림2(git log —oneline)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;필자는 두번째로 가장 오래된 commit 시점으로 rewind를 해볼것이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Rewind 순서&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;git rebase -i —root&lt;/li&gt;
  &lt;li&gt;되감고 싶은 시점에 해당하는 commit에 가장 앞에 위치한 pick을 edit으로 바꾼다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/2021-08-01/rebase_i.png&quot; alt=&quot;rebase_i.png&quot; class=&quot;align-center&quot; width=&quot;100%&amp;quot;, height=&amp;quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;image-caption&quot;&gt;&lt;em&gt;그림2(git rebase_i)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/2021-08-01/rebase_i_result.png&quot; alt=&quot;rebase_i_result.png&quot; class=&quot;align-center&quot; width=&quot;100%&amp;quot;, height=&amp;quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;image-caption&quot;&gt;&lt;em&gt;그림2(git rebase -i 결과)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;그럼 다음과 같은 결과 메세지를 볼 수 있다. 864cf0f… ID를 가지는 commit 시점으로 바뀐것이다.&lt;/p&gt;

&lt;p&gt;정말로 그런지 git log —oneline으로 확인해보자!!!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/2021-08-01/rewind_result.png&quot; alt=&quot;rewind_result.png&quot; class=&quot;align-center&quot; width=&quot;100%&amp;quot;, height=&amp;quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;image-caption&quot;&gt;&lt;em&gt;그림2(rewind 결과)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;정말로 해당 시점으로 되감아진것을 확인할 수 있다. 마치 타임머신처럼 기능을 한다🤩&lt;/p&gt;

&lt;p&gt;타임머신을 탔는데 다시 돌아올 방법이 없다면 정말 곤란할 것 같다… 다행히 rebase명령어는 다시 이전 시점으로 돌아올 수 있는 옵션을 제공한다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git rebase &lt;span class=&quot;nt&quot;&gt;--continue&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;rebase-실습1&quot;&gt;Rebase 실습1&lt;/h1&gt;

&lt;h2 id=&quot;가장-오래된-역사-부터-두번째-commit-이후에-새로운-commit-3개-넣기&quot;&gt;가장 오래된 역사 부터 두번째 commit 이후에 새로운 commit 3개 넣기&lt;/h2&gt;

&lt;p&gt;위에 rewind에 관한 내용을 잘 숙지했다면 어려운 내용은 아닌것 같다.&lt;/p&gt;

&lt;p&gt;가장 오래된 역사 두번째 commit으로 rewind후 commit을 3개 만들면 되는 간단한 실습이었다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/2021-08-01/practice_1.png&quot; alt=&quot;practice_1.png&quot; class=&quot;align-center&quot; width=&quot;100%&amp;quot;, height=&amp;quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;image-caption&quot;&gt;&lt;em&gt;그림2(practice 1 해답)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;마찬가지로 git log로 결과를 확인해보자. 확인해본결과 Add knapsack… commit이후 3개의 commit이 잘 들어간것을 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/2021-08-01/practice_1_result.png&quot; alt=&quot;rebase_i.png&quot; class=&quot;align-center&quot; width=&quot;100%&amp;quot;, height=&amp;quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;image-caption&quot;&gt;&lt;em&gt;그림2(practice 1 git log)&lt;/em&gt;&lt;/p&gt;

&lt;p class=&quot;notice--primary&quot;&gt;&lt;strong&gt;Primary Notice:&lt;/strong&gt; 해당 포스트는 리얼리눅스 송태웅님의 강의를 보고 정리한 내용임을 알립니다.&lt;/p&gt;</content><author><name>YongJun Kwon</name><email>ubermen5ch1308@gmail.com</email></author><category term="Git" /><category term="대외 활동" /><category term="Git/Github" /><category term="git 명령어" /><category term="rebase" /><category term="오픈소스" /><summary type="html">Rebase의 필요성</summary></entry><entry><title type="html">[컨트리뷰톤] Git/GitHub 기본실습-1</title><link href="https://ubermen5che.github.io/git/%EB%8C%80%EC%99%B8%20%ED%99%9C%EB%8F%99/%EC%BB%A8%ED%8A%B8%EB%A6%AC%EB%B7%B0%ED%86%A4-Git-%EA%B8%B0%EB%B3%B8%EC%8B%A4%EC%8A%B5-1/" rel="alternate" type="text/html" title="[컨트리뷰톤] Git/GitHub 기본실습-1" /><published>2021-07-31T00:00:00+09:00</published><updated>2021-07-31T00:00:00+09:00</updated><id>https://ubermen5che.github.io/git/%EB%8C%80%EC%99%B8%20%ED%99%9C%EB%8F%99/%5B%EC%BB%A8%ED%8A%B8%EB%A6%AC%EB%B7%B0%ED%86%A4%5DGit%20%EA%B8%B0%EB%B3%B8%EC%8B%A4%EC%8A%B5-1</id><content type="html" xml:base="https://ubermen5che.github.io/git/%EB%8C%80%EC%99%B8%20%ED%99%9C%EB%8F%99/%EC%BB%A8%ED%8A%B8%EB%A6%AC%EB%B7%B0%ED%86%A4-Git-%EA%B8%B0%EB%B3%B8%EC%8B%A4%EC%8A%B5-1/">&lt;h1 id=&quot;오픈소스-프로젝트-복사--다운-받기fork--clone&quot;&gt;오픈소스 프로젝트 복사 / 다운 받기(Fork &amp;amp; Clone)&lt;/h1&gt;

&lt;p&gt;우선 Fork하는 행위에 대한 의미를 알아보자. Fork를 이해하려면 우선 commit의 기본개념을 알아야한다.&lt;/p&gt;

&lt;h3 id=&quot;커밋이란&quot;&gt;커밋이란?&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;소스파일의 변화분이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/2021-07-31/commit_log.png&quot; alt=&quot;commit_log.png&quot; class=&quot;align-center&quot; width=&quot;100%&amp;quot;, height=&amp;quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;image-caption&quot;&gt;&lt;em&gt;그림1(커밋 로그)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Fork는 Fork한 프로젝트의 commit내역을 모두 복사한것과 동일하다고 생각하면 쉽다. 즉 내가 fork한 프로젝트와는 별개의 복사된 프로젝트라고 보면된다. 복사된 프로젝트이니 당연히 fork한 프로젝트를 수정한다고 해서 원본 프로젝트에 대해 전혀 영향을 줄 수 없다! 만약 내가 fork해온 오픈소스 프로젝트에 대해 버그를 발견하거나 내용추가가 필요한 경우 어떻게 원본 프로젝트에 반영할 수 있을까? 해당내용은 뒤에서 다루도록 하겠다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/2021-07-31/fork_clone.png&quot; alt=&quot;fork_clone.png&quot; class=&quot;align-center&quot; width=&quot;100%&amp;quot;, height=&amp;quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;image-caption&quot;&gt;&lt;em&gt;그림2(fork와 clone)&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&quot;개발자가-오픈소스를-읽는-방법git-project-reading-skill&quot;&gt;개발자가 오픈소스를 읽는 방법(Git project Reading Skill)&lt;/h1&gt;

&lt;h2 id=&quot;git-shortlog&quot;&gt;git shortlog&lt;/h2&gt;

&lt;p&gt;내가 fork해온 오픈소스 프로젝트에서 누가 제일 개발을 많이한지 분명 궁금할 것이다 이럴 때 사용할 수 있는 명령어는 아래와 같다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git shortlog &lt;span class=&quot;nt&quot;&gt;-sn&lt;/span&gt; | &lt;span class=&quot;nb&quot;&gt;nl&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/2021-07-31/shortlog_sn.png&quot; alt=&quot;shortlog_sn.png&quot; class=&quot;align-center&quot; width=&quot;100%&amp;quot;, height=&amp;quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;image-caption&quot;&gt;&lt;em&gt;그림3(git shortlog -sn)&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;git shortlog -s(개발자별 commit 개수 요약)&lt;/li&gt;
  &lt;li&gt;git shortlog -n(개발자별 commit 개수 순위 정리)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;내가 이번 3개월의 기간동안 컨트리뷰톤을 참여하면서 기여하게될 프로젝트인 “FOSSLight” 프로젝트에 대해서 해당 명령어를 사용해보았다. 그 결과 위와 같은 결과가 나왔다 이 결과는 단지 commit결과의 수를 기준으로 요약한 결과이다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git shortlog &lt;span class=&quot;nt&quot;&gt;-sn&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--no-merges&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;git shortlog 사용시 —no-merges 옵션을 사용하면 Merge commit을 제외한 commit수를 산정할 수 있다.&lt;/p&gt;

&lt;p&gt;여기서 Merge commit이란 별다른 수정내역이 없는 commit이다. 단지 다른 사람이 commit한것을 merge했다라는 표시만 남기는 의미를 가지는 commit이다. 따라서 —no-merges 옵션을 사용하면 순수히 코드 변경과 관련된 커밋수만 확인해볼 수 있는것이다.&lt;/p&gt;

&lt;h2 id=&quot;git-log&quot;&gt;git log&lt;/h2&gt;

&lt;p&gt;전체 소스파일수정 내역(commit)은 몇개인지 알아보고자 할 때 사용하는 명령어는 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git log &lt;span class=&quot;nt&quot;&gt;--oneline&lt;/span&gt; | &lt;span class=&quot;nb&quot;&gt;wc&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-l&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;참고로 wc -l 명령은(파일) 라인수 개수를 측정해주는 명령어이다. 또한 명령에 사이에 위치한 bar는 파이프라인 명령어 기호로 파이프라인 기호 앞에 위치하는 명령어의 결과를 파이프라인 기호 뒤의 명령어의 입력으로 넣어주는 기능을하는 명령어이다. 추가적인 내용은 linux command line 관련 문서를 참고하면 좋을듯하다.&lt;/p&gt;

&lt;p&gt;git log를 이용하면 commit 각각의 ID를 확인해볼 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git log &lt;span class=&quot;nt&quot;&gt;--oneline&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/2021-07-31/git_log_oneline.png&quot; alt=&quot;git_log_oneline.png&quot; class=&quot;align-center&quot; width=&quot;100%&amp;quot;, height=&amp;quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;image-caption&quot;&gt;&lt;em&gt;그림3(git log —oneline)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;여기서 노란색으로 표시된 해쉬값이 ID이다. 각 ID는 SHA1 방식으로 해싱된 값으로 고유한 ID를 갖는다. 위의 커밋들 중에서 소스파일 수정내역(commit)dmf 확인해보고 싶다면 git show 명령어를 사용해보자.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git show &amp;lt;ID&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/2021-07-31/git_show.png&quot; alt=&quot;git_show.png&quot; class=&quot;align-center&quot; width=&quot;100%&amp;quot;, height=&amp;quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;image-caption&quot;&gt;&lt;em&gt;그림4(git show)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;필자는 6237748이라는 ID를 가지는 commit에 대해 git show를 하였고 위 그림4는 이에 대한 결과를 나타낸다. git show를 이용하면 해당 커밋에 대해서 수정한 소스파일 개수가 얼마나 되는지 알아볼 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/2021-07-31/git_show_diff.png&quot; alt=&quot;git_show_diff.png&quot; class=&quot;align-center&quot; width=&quot;100%&amp;quot;, height=&amp;quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;image-caption&quot;&gt;&lt;em&gt;그림5(소스파일 수정 개수)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;그림5를 보면 grep명령어를 이용해서 “diff —git”이라는 문자열을 검색해본것을 볼 수 있다. diff-git이 소스파일의 수정을 뜻하는 의미인것 같다. 결과를 보면 총 4가지 파일이 수정된것을 확인할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;PartnerMaster.java → PartnerMaster.java&lt;/li&gt;
  &lt;li&gt;PartnerMapper.java → PartnerMapper.java&lt;/li&gt;
  &lt;li&gt;PartnerServiceImpl.java → ParterServiceImpl.java&lt;/li&gt;
  &lt;li&gt;PartnerMapper.xml → PartnerMapper.xml&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;결과를 자세히 보면&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;diff –git a/src/main/java/oss/fosslight/domain/PartnerMaster.java b/src/main/java/oss/fosslight/domain/PartnerMaster.java&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이러한 결과를 볼 수 있는데, diff 파일경로의 가장 앞에 나타나는 a와 b가 의미하는 바는 상태a에서 상태b로 변경되었다는것을 표시하는 문자이고 두 상태 모두 같은 경로의 파일을 나타내고있다. 이는 a → b상태에서 경로 및 파일명 변경이 일어나지 않았고 오직 PartnerMaster.java 파일 내부의 소스코드만이 변경되었다는것을 뜻한다. 나머지 3개의 파일에 대해서도 동일한 결과를 보여주고 있다.&lt;/p&gt;

&lt;h3 id=&quot;특정-기준-수정내역commit-리스트-확인-방법&quot;&gt;특정 기준 수정내역(commit) 리스트 확인 방법&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;특정 소스파일 기준 수정내역 리스트 확인&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  git log &lt;span class=&quot;nt&quot;&gt;--oneline&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt; &amp;lt;파일명&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;특정 날짜기준 수정내역 리스트 확인&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;c&quot;&gt;#2020년 1월 부터 2020년 6월30일까지 소스 수정내역(commit) 리스트 확인&lt;/span&gt;
  git log &lt;span class=&quot;nt&quot;&gt;--oneline&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--after&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;2020-01-01 &lt;span class=&quot;nt&quot;&gt;--before&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;2020-06-30
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;특정 날짜+파일기준 수정내역 리스트 확인&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  git log &lt;span class=&quot;nt&quot;&gt;--oneline&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--after&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;2020-06-01 &lt;span class=&quot;nt&quot;&gt;--before&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;2020-06-30 &lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt; &amp;lt;파일명&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;옛날것부터 소스파일 수정내역 보기&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  git log &lt;span class=&quot;nt&quot;&gt;--reverse&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;최초 커밋을 확인할 때 유용.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p class=&quot;notice--primary&quot;&gt;&lt;strong&gt;Primary Notice:&lt;/strong&gt; 해당 포스트는 리얼리눅스 송태웅님의 강의를 보고 정리한 내용임을 알립니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>YongJun Kwon</name><email>ubermen5ch1308@gmail.com</email></author><category term="Git" /><category term="대외 활동" /><category term="Git/Github" /><category term="git 명령" /><summary type="html">오픈소스 프로젝트 복사 / 다운 받기(Fork &amp;amp; Clone)</summary></entry><entry><title type="html">[Spring] 싱글톤 컨테이너</title><link href="https://ubermen5che.github.io/spring/design%20pattern/Spring-%EC%8B%B1%EA%B8%80-%ED%86%A4-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88/" rel="alternate" type="text/html" title="[Spring] 싱글톤 컨테이너" /><published>2021-07-27T00:00:00+09:00</published><updated>2021-07-27T00:00:00+09:00</updated><id>https://ubermen5che.github.io/spring/design%20pattern/%5BSpring%5D%20%EC%8B%B1%EA%B8%80%1D%ED%86%A4%20%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88</id><content type="html" xml:base="https://ubermen5che.github.io/spring/design%20pattern/Spring-%EC%8B%B1%EA%B8%80-%ED%86%A4-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88/">&lt;h1 id=&quot;웹-어플리케이션과-싱글톤&quot;&gt;웹 어플리케이션과 싱글톤&lt;/h1&gt;

&lt;p&gt;웹 어플리케이션은 보통 수많은 클라이언트가 동시에 요청을 한다. 만약 클라이언트의 요청마다 새로운 객체(Controller)를 생성해서 서비스하게 된다면 JVM에 수많은 객체가 등록되고 결국 OOM(Out Of Memory)가 발생하여 정상적으로 서비스를 할 수 없게 될것이다. 이를 해결하기 위해 나온것이 싱글톤 컨테이너이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/2021-07-27/DI_container.png&quot; alt=&quot;DI 컨테이너&quot; class=&quot;align-center&quot; width=&quot;70%&amp;quot;, height=&amp;quot;70%&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;image-caption&quot;&gt;&lt;em&gt;그림1(DI 컨테이너)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;그림1은 스프링 없는 순수한 DI 컨테이너인 AppConfig가 요청을 할 때마다 객체를 새로 생성하는 상황을 나타낸다. 분명 같은 기능을 하는 객체인데 요청마다 새로 생성하는것은 언듯봐도 비효율적으로 보인다. 이를 해결하기 위한 획기적인 방법은 없을까?&lt;/p&gt;

&lt;p&gt;해결방안으로는 해당 객체를 오직 하나만 생성해서 공유하도록 설계하면 될것이다!!(싱글톤 패턴)&lt;/p&gt;

&lt;h1 id=&quot;싱글톤-패턴&quot;&gt;싱글톤 패턴&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;클래스의 인스턴스가 하나만 생성되는 것을 보장하는 디자인 패턴이다.&lt;/li&gt;
  &lt;li&gt;따라서 객체 인스턴스를 2개 이상 생성하지 못하도록 막아야 한다.
    &lt;ul&gt;
      &lt;li&gt;private 생성자를 사용해서 외부에서 임의로 new 키워드를 사용하지 못하도록 막는 방법이 존재한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;싱글톤-패턴-예제-코드&quot;&gt;싱글톤 패턴 예제 코드&lt;/h2&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SingletonService&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;//1. static 영역에 객체를 딱 1개만 생성해둔다.&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SingletonService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SingletonService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;//2. public으로 열어서 객체 인스턴스가 필요하면 이 static 메서드를 통해서만 조회하도록 허용한다.&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SingletonService&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getInstance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;instance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;//3. 생성자를 private로 선언해서 외부에서 new 키워드를 사용한 객체 생성을 못하게 막는다.(은근 많이쓰는 방법)&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;SingletonService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;logic&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;싱글톤 객체 로직 호출&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;싱글톤-패턴-문제점&quot;&gt;싱글톤 패턴 문제점&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;싱글톤 패턴을 구현하는 코드 자체가 많이 들어간다
    &lt;ul&gt;
      &lt;li&gt;Appconfig에 Bean으로 등록되어있는 객체들에 대해 모두 싱글톤 패턴을 적용해야 하는데 상당한 노가다 작업이 예상된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;의존관계상 클라이언트가 구체 클래스에 의존한다 → DIP를 위반한다
    &lt;ul&gt;
      &lt;li&gt;memberService → memberRepositoryImpl 와 같은 의존관계를 가지는데 이 때 싱글톤 패턴을 적용하려면 Appconfig내에서 구체 클래스인 memberRepositoryImpl에 대해서 코드 수정이 필요하게되기 때문.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;클라이언트가 구체 클래스에 의존해서 OCP 원칙을 위반할 가능성이 높다.&lt;/li&gt;
  &lt;li&gt;테스트하기 어렵다.
    &lt;ul&gt;
      &lt;li&gt;싱글톤을 이용하는 경우 대부분 인터페이스가 아닌 콘크리트 클래스의 객체를 미리 생성해놓고 정적 메소드를 이용하여 사용하게 된다. 이는 여러 SOLID원칙을 위반할 수 있는 가능성을 열어둠과 동시에, 싱글톤을 사용하는 곳과 싱글톤 클래스 사이에 의존성이 생기게 된다. 클래스 사이에 강한 의존성, 즉 높은 결합이 생기게 되면 수정, 단위테스트의 어려움 등 다양한 문제가 발생한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;내부 속성을 변경하거나 초기화 하기 어렵다.&lt;/li&gt;
  &lt;li&gt;private 생성자로인해 상속할 수 없다.&lt;/li&gt;
  &lt;li&gt;결론적으로 유연성이 떨어진다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;싱글톤-컨테이너&quot;&gt;싱글톤 컨테이너&lt;/h1&gt;

&lt;p&gt;스프링 컨테이너는 싱글톤 패턴의 문제점을 해결하면서, 객체 인스턴스를 싱글톤(1만개 생성)으로 관리한다.&lt;/p&gt;

&lt;p&gt;스프링빈은 싱글톤으로 관리된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;스프링 컨테이너는 싱글톤 패턴을 적용하지 않아도, 객체 인스턴스를 싱글톤으로 관리한다.&lt;/li&gt;
  &lt;li&gt;스프링 컨테이너는 싱글톤 컨테이너 역할을 한다. 이렇게 싱글톤 객체를 생성하고 관리하는 기능을 싱글톤 레지스트리라 한다.&lt;/li&gt;
  &lt;li&gt;스프링 컨테이너의 이런 기능 덕분에 싱글톤 패턴의 모든 단점을 해결하면서 객체를 싱글톤으로 유지할 수 있다.&lt;/li&gt;
  &lt;li&gt;싱글톤 패턴을 위한 지저분한 코드가 들어가지 않아도 된다.&lt;/li&gt;
  &lt;li&gt;DIP, OCP, 테스트, private 생성자로 부터 자유롭게 싱글톤을 사용할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;싱글톤-컨테이너-적용-후&quot;&gt;싱글톤 컨테이너 적용 후&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/2021-07-27/singleton.png&quot; alt=&quot;singleton.png&quot; class=&quot;align-center&quot; width=&quot;70%&amp;quot;, height=&amp;quot;70%&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;image-caption&quot;&gt;&lt;em&gt;그림2(스프링 컨테이너)&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;스프링 컨테이너 덕분에 고객의 요청이 올 때마다 새로운 객체를 생성하지 않고, 이미 만들어진 객체를 공유해서 효율적으로 재사용이 가능하다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;참고: 스프링의 기본 빈 등록 방식은 싱글톤이지만, 경우에 따라 요청시 새로운 객체를 생성해서 반환하는 기능도 제공한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;싱글톤-방식의-주의점&quot;&gt;싱글톤 방식의 주의점&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;싱글톤 패턴이든, 스프링 같은 싱글톤 컨테이너를 사용하든, 객체 인스턴스를 하나만 생성해서 공유하는 싱글톤 방식은 여러 클라이언트가 하나의 같은 객체 인스턴스를 공유하기 때문에 싱글톤 객체는 상태를 유지(stateful)하게 설계하면 안된다.&lt;/li&gt;
  &lt;li&gt;무상태(stateless)로 설계해야 한다!
    &lt;ul&gt;
      &lt;li&gt;특정 클라이언트에 의존적인 필드가 있으면 안된다.&lt;/li&gt;
      &lt;li&gt;특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안된다!&lt;/li&gt;
      &lt;li&gt;가급적 읽기만 가능해야 한다.&lt;/li&gt;
      &lt;li&gt;필드 대신에 자바에서 공유되지 않는, 지역변수, 파라미터, ThreadLocal 등을 사용해야 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;스프링 빈의 필드에 공유 값을 설정하면 정말 큰 장애가 발생할 수 있다&lt;/li&gt;
&lt;/ul&gt;</content><author><name>YongJun Kwon</name><email>ubermen5ch1308@gmail.com</email></author><category term="Spring" /><category term="Design pattern" /><category term="Spring" /><category term="singleton" /><summary type="html">웹 어플리케이션과 싱글톤</summary></entry><entry><title type="html">대구시 어린이 교통사고와 어린이 보호구역의 연관성</title><link href="https://ubermen5che.github.io/datavisualization/The-relationship-between-child-traffic-accidents-and-child-protection-areas-in-Daegu/" rel="alternate" type="text/html" title="대구시 어린이 교통사고와 어린이 보호구역의 연관성" /><published>2021-07-16T00:00:00+09:00</published><updated>2021-07-16T00:00:00+09:00</updated><id>https://ubermen5che.github.io/datavisualization/The%20relationship%20between%20child%20traffic%20accidents%20and%20child%20protection%20areas%20in%20Daegu</id><content type="html" xml:base="https://ubermen5che.github.io/datavisualization/The-relationship-between-child-traffic-accidents-and-child-protection-areas-in-Daegu/">&lt;h1 id=&quot;folium을-이용한-데이터-시각화&quot;&gt;Folium을 이용한 데이터 시각화&lt;/h1&gt;

&lt;h2 id=&quot;시각화-자료-정보&quot;&gt;시각화 자료 정보&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- 마커로 표시된 위치는 2013년도부터 2020년도 까지의 대구시 어린이 교통사고 발생 위치를 나타냄.
- 클릭시 세부정보 확인 가능.
- 노란색 원은 어런이 보호구역을 나타냄.
- 원의 반지름은 200M로 설정하였음.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;content&quot; stype=&quot;transform: translate3d(0px, 0px, 0px);&quot;&gt;
     &lt;iframe src=&quot;/assets/html/posts/2021-07-16/index.html&quot; width=&quot;100%&quot; height=&quot;500pt&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;</content><author><name>YongJun Kwon</name><email>ubermen5ch1308@gmail.com</email></author><category term="Datavisualization" /><category term="Folium" /><summary type="html">Folium을 이용한 데이터 시각화</summary></entry><entry><title type="html">[스프링 핵심 원리] SOLID</title><link href="https://ubermen5che.github.io/java/spring/%EC%9E%90%EB%B0%94-%EC%8A%A4%ED%94%84%EB%A7%81-SOLID/" rel="alternate" type="text/html" title="[스프링 핵심 원리] SOLID" /><published>2021-07-05T00:00:00+09:00</published><updated>2021-07-05T00:00:00+09:00</updated><id>https://ubermen5che.github.io/java/spring/%5B%EC%9E%90%EB%B0%94%20%EC%8A%A4%ED%94%84%EB%A7%81%5D%20SOLID</id><content type="html" xml:base="https://ubermen5che.github.io/java/spring/%EC%9E%90%EB%B0%94-%EC%8A%A4%ED%94%84%EB%A7%81-SOLID/">&lt;h2 id=&quot;srp-단일-책임-원칙single-responsibility-principle&quot;&gt;SRP: 단일 책임 원칙(Single responsibility principle)&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;한 클래스는 하나의 책임만 가져야 한다.&lt;/li&gt;
  &lt;li&gt;하나의 책임이라는 것은 모호하다.
    &lt;ul&gt;
      &lt;li&gt;클 수 있고, 작을 수 있다.&lt;/li&gt;
      &lt;li&gt;문맥과 상황에 따라 다르다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;중요한 기준은 변경이다. 변경이 있을 때 파급 효과가 적으면 단일 책임 원칙을 잘 따른 것
    &lt;ul&gt;
      &lt;li&gt;예) UI변경, 객체의 생성과 사용을 분리&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;️ocp-개방-폐쇄-원칙openclosed-principle️&quot;&gt;⭐️OCP: 개방-폐쇄 원칙(Open/closed principle)⭐️&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야&lt;/strong&gt; 한다.
    &lt;ul&gt;
      &lt;li&gt;확장을 하려면 당연히 기존 코드를 변경해야하는것이 아닌가?&lt;/li&gt;
      &lt;li&gt;인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능을 구현&lt;/li&gt;
      &lt;li&gt;다형성을 활용해보자.&lt;/li&gt;
      &lt;li&gt;이렇게 하면 기존 코드를 변경한 것이 아님. 그저 역할에 맞는 구현체를 새로 생성한것이므로 확장에는 열려있으나 변경에는 닫혀있다는말이 일리가 있음.(역할과 구현의 분리를 생각해보자)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;OCP 문제점이 존재함
    &lt;ul&gt;
      &lt;li&gt;구현 객체를 변경하려할 때 클라이언트 코드를 변경해야하는 상황이 발생할 수 있다.
        &lt;ul&gt;
          &lt;li&gt;분명 다형성을 사용했지만 OCP 원칙을 지킬 수 없다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;이 문제를 해결하기 위해서는 객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자가 필요하다
        &lt;ul&gt;
          &lt;li&gt;스프링 컨테이너가 해결해준다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;lsp-리스코프-치환-원칙liskov-substitution-principle&quot;&gt;LSP: 리스코프 치환 원칙(Liskov substitution principle)&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스를 바꿀 수 있어야 한다.&lt;/li&gt;
  &lt;li&gt;다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야 한다는 것, 다형성을 지원하기 위한 원칙, 인터페이스를 구현한 구현체는 믿고 사용하려면, 이 원칙이 필요.&lt;/li&gt;
  &lt;li&gt;단순히 컴파일에 성공하는 것을 넘어서는 맥락.&lt;/li&gt;
  &lt;li&gt;예) 자동차 인터페이스의 엑셀은 앞으로 가라는 기능, 뒤로 가게 구현하면 LSP위반, 느리더라도 앞으로 가야함.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;isp-인터페이스-분리-원칙interface-segregation-principle&quot;&gt;ISP: 인터페이스 분리 원칙(Interface segregation principle)&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;특정 클라이언트를 위한 인터페이스 여러개가 범용 인터페이스 하나보다 낫다&lt;/li&gt;
  &lt;li&gt;자동차 인터페이스 → 운전 인터페이스, 정비 인터페이스로 분리&lt;/li&gt;
  &lt;li&gt;사용자 클라이언트 → 운전자 클라이언트, 정비사 클라이언트로 분리&lt;/li&gt;
  &lt;li&gt;분리하면 정비 인터페이스 자체가 변해도 운전자 클라이언트에 영향을 주지 않음&lt;/li&gt;
  &lt;li&gt;인터페이스가 명확해지고, 대체 가능성이 높아진다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;️dip-의존관계-역전-원칙dependency-inversion-principle️&quot;&gt;⭐️DIP 의존관계 역전 원칙(Dependency inversion principle)⭐️&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;프로그래머는 “추상화에 의존해야지, 구체화에 의존하면 안된다.” 의존성 주입은 이 원칙을 따르는 방법 중 하나다.&lt;/li&gt;
  &lt;li&gt;쉽게 말해서 구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 뜻&lt;/li&gt;
  &lt;li&gt;역할에 의존하게 해야한다는 말과 같다. 객체 세상도 클라이언트가 인터페이스에 의존해야 유연하게 구현체를 변경할 수 있다! 구현체에 의존하게 되면 변경이 아주 어려워진다.&lt;/li&gt;
  &lt;li&gt;비즈니스 로직을 담은 객체가 Repository 인터페이스를 의존하면서, Repository 구현체 또한 의존하고 있을 경우 DIP위반.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;정리&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;객체 지향의 핵심은 다형성&lt;/li&gt;
  &lt;li&gt;다형성 만으로는 쉽게 부품을 갈아 끼우듯이 개발할 수 없다.&lt;/li&gt;
  &lt;li&gt;구현 객체를 변경할 때 클라이언트 코드도 함께 변경된다.&lt;/li&gt;
  &lt;li&gt;다형성 만으로는 OCP, DIP를 지킬 수 없다.&lt;/li&gt;
  &lt;li&gt;뭔가 더 필요하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;해당 내용은 김영한님의 [자바 스프링 핵심 원리] 기본편의 강의 내용을 정리한 포스팅임을 밝힙니다.&lt;/p&gt;</content><author><name>YongJun Kwon</name><email>ubermen5ch1308@gmail.com</email></author><category term="Java" /><category term="Spring" /><category term="Java" /><category term="Spring" /><category term="SOLID" /><summary type="html">SRP: 단일 책임 원칙(Single responsibility principle)</summary></entry></feed>