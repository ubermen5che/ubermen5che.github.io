<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="https://ubermen5che.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://ubermen5che.github.io/" rel="alternate" type="text/html" /><updated>2021-08-01T00:41:22+09:00</updated><id>https://ubermen5che.github.io/feed.xml</id><title type="html">Ubermen5che’s Blog</title><subtitle>My first private blog</subtitle><author><name>YongJun Kwon</name><email>ubermen5ch1308@gmail.com</email></author><entry><title type="html">[컨트리뷰톤] Git/GitHub 기본실습-1</title><link href="https://ubermen5che.github.io/git/%EB%8C%80%EC%99%B8%20%ED%99%9C%EB%8F%99/%EC%BB%A8%ED%8A%B8%EB%A6%AC%EB%B7%B0%ED%86%A4-Git-%EA%B8%B0%EB%B3%B8%EC%8B%A4%EC%8A%B5-1/" rel="alternate" type="text/html" title="[컨트리뷰톤] Git/GitHub 기본실습-1" /><published>2021-07-31T00:00:00+09:00</published><updated>2021-07-31T00:00:00+09:00</updated><id>https://ubermen5che.github.io/git/%EB%8C%80%EC%99%B8%20%ED%99%9C%EB%8F%99/%5B%EC%BB%A8%ED%8A%B8%EB%A6%AC%EB%B7%B0%ED%86%A4%5DGit%20%EA%B8%B0%EB%B3%B8%EC%8B%A4%EC%8A%B5-1</id><content type="html" xml:base="https://ubermen5che.github.io/git/%EB%8C%80%EC%99%B8%20%ED%99%9C%EB%8F%99/%EC%BB%A8%ED%8A%B8%EB%A6%AC%EB%B7%B0%ED%86%A4-Git-%EA%B8%B0%EB%B3%B8%EC%8B%A4%EC%8A%B5-1/">&lt;h1 id=&quot;오픈소스-프로젝트-복사--다운-받기fork--clone&quot;&gt;오픈소스 프로젝트 복사 / 다운 받기(Fork &amp;amp; Clone)&lt;/h1&gt;

&lt;p&gt;우선 Fork하는 행위에 대한 의미를 알아보자. Fork를 이해하려면 우선 commit의 기본개념을 알아야한다.&lt;/p&gt;

&lt;h3 id=&quot;커밋이란&quot;&gt;커밋이란?&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;소스파일의 변화분이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/2021-07-31/commit_log.png&quot; alt=&quot;commit_log.png&quot; class=&quot;align-center&quot; width=&quot;70%&amp;quot;, height=&amp;quot;70%&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;image-caption&quot;&gt;&lt;em&gt;그림1(커밋 로그)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Fork는 Fork한 프로젝트의 commit내역을 모두 복사한것과 동일하다고 생각하면 쉽다. 즉 내가 fork한 프로젝트와는 별개의 복사된 프로젝트라고 보면된다. 복사된 프로젝트이니 당연히 fork한 프로젝트를 수정한다고 해서 원본 프로젝트에 대해 전혀 영향을 줄 수 없다! 만약 내가 fork해온 오픈소스 프로젝트에 대해 버그를 발견하거나 내용추가가 필요한 경우 어떻게 원본 프로젝트에 반영할 수 있을까? 해당내용은 뒤에서 다루도록 하겠다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/2021-07-31/fork_clone.png&quot; alt=&quot;fork_clone.png&quot; class=&quot;align-center&quot; width=&quot;70%&amp;quot;, height=&amp;quot;70%&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;image-caption&quot;&gt;&lt;em&gt;그림2(fork와 clone)&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&quot;개발자가-오픈소스를-읽는-방법git-project-reading-skill&quot;&gt;개발자가 오픈소스를 읽는 방법(Git project Reading Skill)&lt;/h1&gt;

&lt;h2 id=&quot;git-shortlog&quot;&gt;git shortlog&lt;/h2&gt;

&lt;p&gt;내가 fork해온 오픈소스 프로젝트에서 누가 제일 개발을 많이한지 분명 궁금할 것이다 이럴 때 사용할 수 있는 명령어는 아래와 같다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git shortlog &lt;span class=&quot;nt&quot;&gt;-sn&lt;/span&gt; | &lt;span class=&quot;nb&quot;&gt;nl&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/2021-07-31/shortlog_sn.png&quot; alt=&quot;shortlog_sn.png&quot; class=&quot;align-center&quot; width=&quot;70%&amp;quot;, height=&amp;quot;70%&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;image-caption&quot;&gt;&lt;em&gt;그림3(git shortlog -sn)&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;git shortlog -s(개발자별 commit 개수 요약)&lt;/li&gt;
  &lt;li&gt;git shortlog -n(개발자별 commit 개수 순위 정리)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;내가 이번 3개월의 기간동안 컨트리뷰톤을 참여하면서 기여하게될 프로젝트인 “FOSSLight” 프로젝트에 대해서 해당 명령어를 사용해보았다. 그 결과 위와 같은 결과가 나왔다 이 결과는 단지 commit결과의 수를 기준으로 요약한 결과이다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git shortlog &lt;span class=&quot;nt&quot;&gt;-sn&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--no-merges&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;git shortlog 사용시 —no-merges 옵션을 사용하면 Merge commit을 제외한 commit수를 산정할 수 있다.&lt;/p&gt;

&lt;p&gt;여기서 Merge commit이란 별다른 수정내역이 없는 commit이다. 단지 다른 사람이 commit한것을 merge했다라는 표시만 남기는 의미를 가지는 commit이다. 따라서 —no-merges 옵션을 사용하면 순수히 코드 변경과 관련된 커밋수만 확인해볼 수 있는것이다.&lt;/p&gt;

&lt;h2 id=&quot;git-log&quot;&gt;git log&lt;/h2&gt;

&lt;p&gt;전체 소스파일수정 내역(commit)은 몇개인지 알아보고자 할 때 사용하는 명령어는 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git log &lt;span class=&quot;nt&quot;&gt;--oneline&lt;/span&gt; | &lt;span class=&quot;nb&quot;&gt;wc&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-l&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;참고로 wc -l 명령은(파일) 라인수 개수를 측정해주는 명령어이다. 또한 명령에 사이에 위치한 bar는 파이프라인 명령어 기호로 파이프라인 기호 앞에 위치하는 명령어의 결과를 파이프라인 기호 뒤의 명령어의 입력으로 넣어주는 기능을하는 명령어이다. 추가적인 내용은 linux command line 관련 문서를 참고하면 좋을듯하다.&lt;/p&gt;

&lt;p&gt;git log를 이용하면 commit 각각의 ID를 확인해볼 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git log &lt;span class=&quot;nt&quot;&gt;--oneline&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/2021-07-31/git_log_oneline.png&quot; alt=&quot;git_log_oneline.png&quot; class=&quot;align-center&quot; width=&quot;70%&amp;quot;, height=&amp;quot;70%&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;image-caption&quot;&gt;&lt;em&gt;그림3(git log —oneline)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;여기서 노란색으로 표시된 해쉬값이 ID이다. 각 ID는 SHA1 방식으로 해싱된 값으로 고유한 ID를 갖는다. 위의 커밋들 중에서 소스파일 수정내역(commit)dmf 확인해보고 싶다면 git show 명령어를 사용해보자.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git show &amp;lt;ID&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/2021-07-31/git_show.png&quot; alt=&quot;git_show.png&quot; class=&quot;align-center&quot; width=&quot;70%&amp;quot;, height=&amp;quot;70%&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;image-caption&quot;&gt;&lt;em&gt;그림4(git show)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;필자는 6237748이라는 ID를 가지는 commit에 대해 git show를 하였고 위 그림4는 이에 대한 결과를 나타낸다. git show를 이용하면 해당 커밋에 대해서 수정한 소스파일 개수가 얼마나 되는지 알아볼 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/2021-07-31/git_show_diff.png&quot; alt=&quot;git_show_diff.png&quot; class=&quot;align-center&quot; width=&quot;70%&amp;quot;, height=&amp;quot;70%&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;image-caption&quot;&gt;&lt;em&gt;그림5(소스파일 수정 개수)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;그림5를 보면 grep명령어를 이용해서 “diff —git”이라는 문자열을 검색해본것을 볼 수 있다. diff-git이 소스파일의 수정을 뜻하는 의미인것 같다. 결과를 보면 총 4가지 파일이 수정된것을 확인할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;PartnerMaster.java → PartnerMaster.java&lt;/li&gt;
  &lt;li&gt;PartnerMapper.java → PartnerMapper.java&lt;/li&gt;
  &lt;li&gt;PartnerServiceImpl.java → ParterServiceImpl.java&lt;/li&gt;
  &lt;li&gt;PartnerMapper.xml → PartnerMapper.xml&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;결과를 자세히 보면&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;diff –git a/src/main/java/oss/fosslight/domain/PartnerMaster.java b/src/main/java/oss/fosslight/domain/PartnerMaster.java&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이러한 결과를 볼 수 있는데, diff 파일경로의 가장 앞에 나타나는 a와 b가 의미하는 바는 상태a에서 상태b로 변경되었다는것을 표시하는 문자이고 두 상태 모두 같은 경로의 파일을 나타내고있다. 이는 a → b상태에서 경로 및 파일명 변경이 일어나지 않았고 오직 PartnerMaster.java 파일 내부의 소스코드만이 변경되었다는것을 뜻한다. 나머지 3개의 파일에 대해서도 동일한 결과를 보여주고 있다.&lt;/p&gt;

&lt;h3 id=&quot;특정-기준-수정내역commit-리스트-확인-방법&quot;&gt;특정 기준 수정내역(commit) 리스트 확인 방법&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;특정 소스파일 기준 수정내역 리스트 확인&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  git log &lt;span class=&quot;nt&quot;&gt;--oneline&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt; &amp;lt;파일명&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;특정 날짜기준 수정내역 리스트 확인&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;c&quot;&gt;#2020년 1월 부터 2020년 6월30일까지 소스 수정내역(commit) 리스트 확인&lt;/span&gt;
  git log &lt;span class=&quot;nt&quot;&gt;--oneline&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--after&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;2020-01-01 &lt;span class=&quot;nt&quot;&gt;--before&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;2020-06-30
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;특정 날짜+파일기준 수정내역 리스트 확인&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  git log &lt;span class=&quot;nt&quot;&gt;--oneline&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--after&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;2020-06-01 &lt;span class=&quot;nt&quot;&gt;--before&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;2020-06-30 &lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt; &amp;lt;파일명&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;옛날것부터 소스파일 수정내역 보기&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  git log &lt;span class=&quot;nt&quot;&gt;--reverse&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;최초 커밋을 확인할 때 유용.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>YongJun Kwon</name><email>ubermen5ch1308@gmail.com</email></author><category term="Git" /><category term="대외 활동" /><category term="Git/Github" /><summary type="html">오픈소스 프로젝트 복사 / 다운 받기(Fork &amp;amp; Clone)</summary></entry><entry><title type="html">[Spring] 싱글톤 컨테이너</title><link href="https://ubermen5che.github.io/spring/design%20pattern/Spring-%EC%8B%B1%EA%B8%80-%ED%86%A4-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88/" rel="alternate" type="text/html" title="[Spring] 싱글톤 컨테이너" /><published>2021-07-27T00:00:00+09:00</published><updated>2021-07-27T00:00:00+09:00</updated><id>https://ubermen5che.github.io/spring/design%20pattern/%5BSpring%5D%20%EC%8B%B1%EA%B8%80%1D%ED%86%A4%20%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88</id><content type="html" xml:base="https://ubermen5che.github.io/spring/design%20pattern/Spring-%EC%8B%B1%EA%B8%80-%ED%86%A4-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88/">&lt;h1 id=&quot;웹-어플리케이션과-싱글톤&quot;&gt;웹 어플리케이션과 싱글톤&lt;/h1&gt;

&lt;p&gt;웹 어플리케이션은 보통 수많은 클라이언트가 동시에 요청을 한다. 만약 클라이언트의 요청마다 새로운 객체(Controller)를 생성해서 서비스하게 된다면 JVM에 수많은 객체가 등록되고 결국 OOM(Out Of Memory)가 발생하여 정상적으로 서비스를 할 수 없게 될것이다. 이를 해결하기 위해 나온것이 싱글톤 컨테이너이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/2021-07-27/DI_container.png&quot; alt=&quot;DI 컨테이너&quot; class=&quot;align-center&quot; width=&quot;70%&amp;quot;, height=&amp;quot;70%&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;image-caption&quot;&gt;&lt;em&gt;그림1(DI 컨테이너)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;그림1은 스프링 없는 순수한 DI 컨테이너인 AppConfig가 요청을 할 때마다 객체를 새로 생성하는 상황을 나타낸다. 분명 같은 기능을 하는 객체인데 요청마다 새로 생성하는것은 언듯봐도 비효율적으로 보인다. 이를 해결하기 위한 획기적인 방법은 없을까?&lt;/p&gt;

&lt;p&gt;해결방안으로는 해당 객체를 오직 하나만 생성해서 공유하도록 설계하면 될것이다!!(싱글톤 패턴)&lt;/p&gt;

&lt;h1 id=&quot;싱글톤-패턴&quot;&gt;싱글톤 패턴&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;클래스의 인스턴스가 하나만 생성되는 것을 보장하는 디자인 패턴이다.&lt;/li&gt;
  &lt;li&gt;따라서 객체 인스턴스를 2개 이상 생성하지 못하도록 막아야 한다.
    &lt;ul&gt;
      &lt;li&gt;private 생성자를 사용해서 외부에서 임의로 new 키워드를 사용하지 못하도록 막는 방법이 존재한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;싱글톤-패턴-예제-코드&quot;&gt;싱글톤 패턴 예제 코드&lt;/h2&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SingletonService&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;//1. static 영역에 객체를 딱 1개만 생성해둔다.&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SingletonService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SingletonService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;//2. public으로 열어서 객체 인스턴스가 필요하면 이 static 메서드를 통해서만 조회하도록 허용한다.&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SingletonService&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getInstance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;instance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;//3. 생성자를 private로 선언해서 외부에서 new 키워드를 사용한 객체 생성을 못하게 막는다.(은근 많이쓰는 방법)&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;SingletonService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;logic&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;싱글톤 객체 로직 호출&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;싱글톤-패턴-문제점&quot;&gt;싱글톤 패턴 문제점&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;싱글톤 패턴을 구현하는 코드 자체가 많이 들어간다
    &lt;ul&gt;
      &lt;li&gt;Appconfig에 Bean으로 등록되어있는 객체들에 대해 모두 싱글톤 패턴을 적용해야 하는데 상당한 노가다 작업이 예상된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;의존관계상 클라이언트가 구체 클래스에 의존한다 → DIP를 위반한다
    &lt;ul&gt;
      &lt;li&gt;memberService → memberRepositoryImpl 와 같은 의존관계를 가지는데 이 때 싱글톤 패턴을 적용하려면 Appconfig내에서 구체 클래스인 memberRepositoryImpl에 대해서 코드 수정이 필요하게되기 때문.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;클라이언트가 구체 클래스에 의존해서 OCP 원칙을 위반할 가능성이 높다.&lt;/li&gt;
  &lt;li&gt;테스트하기 어렵다.
    &lt;ul&gt;
      &lt;li&gt;싱글톤을 이용하는 경우 대부분 인터페이스가 아닌 콘크리트 클래스의 객체를 미리 생성해놓고 정적 메소드를 이용하여 사용하게 된다. 이는 여러 SOLID원칙을 위반할 수 있는 가능성을 열어둠과 동시에, 싱글톤을 사용하는 곳과 싱글톤 클래스 사이에 의존성이 생기게 된다. 클래스 사이에 강한 의존성, 즉 높은 결합이 생기게 되면 수정, 단위테스트의 어려움 등 다양한 문제가 발생한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;내부 속성을 변경하거나 초기화 하기 어렵다.&lt;/li&gt;
  &lt;li&gt;private 생성자로인해 상속할 수 없다.&lt;/li&gt;
  &lt;li&gt;결론적으로 유연성이 떨어진다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;싱글톤-컨테이너&quot;&gt;싱글톤 컨테이너&lt;/h1&gt;

&lt;p&gt;스프링 컨테이너는 싱글톤 패턴의 문제점을 해결하면서, 객체 인스턴스를 싱글톤(1만개 생성)으로 관리한다.&lt;/p&gt;

&lt;p&gt;스프링빈은 싱글톤으로 관리된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;스프링 컨테이너는 싱글톤 패턴을 적용하지 않아도, 객체 인스턴스를 싱글톤으로 관리한다.&lt;/li&gt;
  &lt;li&gt;스프링 컨테이너는 싱글톤 컨테이너 역할을 한다. 이렇게 싱글톤 객체를 생성하고 관리하는 기능을 싱글톤 레지스트리라 한다.&lt;/li&gt;
  &lt;li&gt;스프링 컨테이너의 이런 기능 덕분에 싱글톤 패턴의 모든 단점을 해결하면서 객체를 싱글톤으로 유지할 수 있다.&lt;/li&gt;
  &lt;li&gt;싱글톤 패턴을 위한 지저분한 코드가 들어가지 않아도 된다.&lt;/li&gt;
  &lt;li&gt;DIP, OCP, 테스트, private 생성자로 부터 자유롭게 싱글톤을 사용할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;싱글톤-컨테이너-적용-후&quot;&gt;싱글톤 컨테이너 적용 후&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/2021-07-27/singleton.png&quot; alt=&quot;singleton.png&quot; class=&quot;align-center&quot; width=&quot;70%&amp;quot;, height=&amp;quot;70%&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;image-caption&quot;&gt;&lt;em&gt;그림2(스프링 컨테이너)&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;스프링 컨테이너 덕분에 고객의 요청이 올 때마다 새로운 객체를 생성하지 않고, 이미 만들어진 객체를 공유해서 효율적으로 재사용이 가능하다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;참고: 스프링의 기본 빈 등록 방식은 싱글톤이지만, 경우에 따라 요청시 새로운 객체를 생성해서 반환하는 기능도 제공한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;싱글톤-방식의-주의점&quot;&gt;싱글톤 방식의 주의점&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;싱글톤 패턴이든, 스프링 같은 싱글톤 컨테이너를 사용하든, 객체 인스턴스를 하나만 생성해서 공유하는 싱글톤 방식은 여러 클라이언트가 하나의 같은 객체 인스턴스를 공유하기 때문에 싱글톤 객체는 상태를 유지(stateful)하게 설계하면 안된다.&lt;/li&gt;
  &lt;li&gt;무상태(stateless)로 설계해야 한다!
    &lt;ul&gt;
      &lt;li&gt;특정 클라이언트에 의존적인 필드가 있으면 안된다.&lt;/li&gt;
      &lt;li&gt;특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안된다!&lt;/li&gt;
      &lt;li&gt;가급적 읽기만 가능해야 한다.&lt;/li&gt;
      &lt;li&gt;필드 대신에 자바에서 공유되지 않는, 지역변수, 파라미터, ThreadLocal 등을 사용해야 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;스프링 빈의 필드에 공유 값을 설정하면 정말 큰 장애가 발생할 수 있다&lt;/li&gt;
&lt;/ul&gt;</content><author><name>YongJun Kwon</name><email>ubermen5ch1308@gmail.com</email></author><category term="Spring" /><category term="Design pattern" /><category term="Spring" /><category term="singleton" /><summary type="html">웹 어플리케이션과 싱글톤</summary></entry><entry><title type="html">대구시 어린이 교통사고와 어린이 보호구역의 연관성</title><link href="https://ubermen5che.github.io/datavisualization/The-relationship-between-child-traffic-accidents-and-child-protection-areas-in-Daegu/" rel="alternate" type="text/html" title="대구시 어린이 교통사고와 어린이 보호구역의 연관성" /><published>2021-07-16T00:00:00+09:00</published><updated>2021-07-16T00:00:00+09:00</updated><id>https://ubermen5che.github.io/datavisualization/The%20relationship%20between%20child%20traffic%20accidents%20and%20child%20protection%20areas%20in%20Daegu</id><content type="html" xml:base="https://ubermen5che.github.io/datavisualization/The-relationship-between-child-traffic-accidents-and-child-protection-areas-in-Daegu/">&lt;h1 id=&quot;folium을-이용한-데이터-시각화&quot;&gt;Folium을 이용한 데이터 시각화&lt;/h1&gt;

&lt;h2 id=&quot;시각화-자료-정보&quot;&gt;시각화 자료 정보&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- 마커로 표시된 위치는 2013년도부터 2020년도 까지의 대구시 어린이 교통사고 발생 위치를 나타냄.
- 클릭시 세부정보 확인 가능.
- 노란색 원은 어런이 보호구역을 나타냄.
- 원의 반지름은 200M로 설정하였음.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;content&quot; stype=&quot;transform: translate3d(0px, 0px, 0px);&quot;&gt;
     &lt;iframe src=&quot;/assets/html/posts/2021-07-16/index.html&quot; width=&quot;100%&quot; height=&quot;500pt&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;</content><author><name>YongJun Kwon</name><email>ubermen5ch1308@gmail.com</email></author><category term="Datavisualization" /><category term="Folium" /><summary type="html">Folium을 이용한 데이터 시각화</summary></entry><entry><title type="html">[스프링 핵심 원리] SOLID</title><link href="https://ubermen5che.github.io/java/spring/%EC%9E%90%EB%B0%94-%EC%8A%A4%ED%94%84%EB%A7%81-SOLID/" rel="alternate" type="text/html" title="[스프링 핵심 원리] SOLID" /><published>2021-07-05T00:00:00+09:00</published><updated>2021-07-05T00:00:00+09:00</updated><id>https://ubermen5che.github.io/java/spring/%5B%EC%9E%90%EB%B0%94%20%EC%8A%A4%ED%94%84%EB%A7%81%5D%20SOLID</id><content type="html" xml:base="https://ubermen5che.github.io/java/spring/%EC%9E%90%EB%B0%94-%EC%8A%A4%ED%94%84%EB%A7%81-SOLID/">&lt;h2 id=&quot;srp-단일-책임-원칙single-responsibility-principle&quot;&gt;SRP: 단일 책임 원칙(Single responsibility principle)&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;한 클래스는 하나의 책임만 가져야 한다.&lt;/li&gt;
  &lt;li&gt;하나의 책임이라는 것은 모호하다.
    &lt;ul&gt;
      &lt;li&gt;클 수 있고, 작을 수 있다.&lt;/li&gt;
      &lt;li&gt;문맥과 상황에 따라 다르다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;중요한 기준은 변경이다. 변경이 있을 때 파급 효과가 적으면 단일 책임 원칙을 잘 따른 것
    &lt;ul&gt;
      &lt;li&gt;예) UI변경, 객체의 생성과 사용을 분리&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;️ocp-개방-폐쇄-원칙openclosed-principle️&quot;&gt;⭐️OCP: 개방-폐쇄 원칙(Open/closed principle)⭐️&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야&lt;/strong&gt; 한다.
    &lt;ul&gt;
      &lt;li&gt;확장을 하려면 당연히 기존 코드를 변경해야하는것이 아닌가?&lt;/li&gt;
      &lt;li&gt;인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능을 구현&lt;/li&gt;
      &lt;li&gt;다형성을 활용해보자.&lt;/li&gt;
      &lt;li&gt;이렇게 하면 기존 코드를 변경한 것이 아님. 그저 역할에 맞는 구현체를 새로 생성한것이므로 확장에는 열려있으나 변경에는 닫혀있다는말이 일리가 있음.(역할과 구현의 분리를 생각해보자)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;OCP 문제점이 존재함
    &lt;ul&gt;
      &lt;li&gt;구현 객체를 변경하려할 때 클라이언트 코드를 변경해야하는 상황이 발생할 수 있다.
        &lt;ul&gt;
          &lt;li&gt;분명 다형성을 사용했지만 OCP 원칙을 지킬 수 없다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;이 문제를 해결하기 위해서는 객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자가 필요하다
        &lt;ul&gt;
          &lt;li&gt;스프링 컨테이너가 해결해준다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;lsp-리스코프-치환-원칙liskov-substitution-principle&quot;&gt;LSP: 리스코프 치환 원칙(Liskov substitution principle)&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스를 바꿀 수 있어야 한다.&lt;/li&gt;
  &lt;li&gt;다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야 한다는 것, 다형성을 지원하기 위한 원칙, 인터페이스를 구현한 구현체는 믿고 사용하려면, 이 원칙이 필요.&lt;/li&gt;
  &lt;li&gt;단순히 컴파일에 성공하는 것을 넘어서는 맥락.&lt;/li&gt;
  &lt;li&gt;예) 자동차 인터페이스의 엑셀은 앞으로 가라는 기능, 뒤로 가게 구현하면 LSP위반, 느리더라도 앞으로 가야함.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;isp-인터페이스-분리-원칙interface-segregation-principle&quot;&gt;ISP: 인터페이스 분리 원칙(Interface segregation principle)&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;특정 클라이언트를 위한 인터페이스 여러개가 범용 인터페이스 하나보다 낫다&lt;/li&gt;
  &lt;li&gt;자동차 인터페이스 → 운전 인터페이스, 정비 인터페이스로 분리&lt;/li&gt;
  &lt;li&gt;사용자 클라이언트 → 운전자 클라이언트, 정비사 클라이언트로 분리&lt;/li&gt;
  &lt;li&gt;분리하면 정비 인터페이스 자체가 변해도 운전자 클라이언트에 영향을 주지 않음&lt;/li&gt;
  &lt;li&gt;인터페이스가 명확해지고, 대체 가능성이 높아진다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;️dip-의존관계-역전-원칙dependency-inversion-principle️&quot;&gt;⭐️DIP 의존관계 역전 원칙(Dependency inversion principle)⭐️&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;프로그래머는 “추상화에 의존해야지, 구체화에 의존하면 안된다.” 의존성 주입은 이 원칙을 따르는 방법 중 하나다.&lt;/li&gt;
  &lt;li&gt;쉽게 말해서 구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 뜻&lt;/li&gt;
  &lt;li&gt;역할에 의존하게 해야한다는 말과 같다. 객체 세상도 클라이언트가 인터페이스에 의존해야 유연하게 구현체를 변경할 수 있다! 구현체에 의존하게 되면 변경이 아주 어려워진다.&lt;/li&gt;
  &lt;li&gt;비즈니스 로직을 담은 객체가 Repository 인터페이스를 의존하면서, Repository 구현체 또한 의존하고 있을 경우 DIP위반.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;정리&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;객체 지향의 핵심은 다형성&lt;/li&gt;
  &lt;li&gt;다형성 만으로는 쉽게 부품을 갈아 끼우듯이 개발할 수 없다.&lt;/li&gt;
  &lt;li&gt;구현 객체를 변경할 때 클라이언트 코드도 함께 변경된다.&lt;/li&gt;
  &lt;li&gt;다형성 만으로는 OCP, DIP를 지킬 수 없다.&lt;/li&gt;
  &lt;li&gt;뭔가 더 필요하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;해당 내용은 김영한님의 [자바 스프링 핵심 원리] 기본편의 강의 내용을 정리한 포스팅임을 밝힙니다.&lt;/p&gt;</content><author><name>YongJun Kwon</name><email>ubermen5ch1308@gmail.com</email></author><category term="Java" /><category term="Spring" /><category term="Java" /><category term="Spring" /><category term="SOLID" /><summary type="html">SRP: 단일 책임 원칙(Single responsibility principle)</summary></entry><entry><title type="html">[Web] 스프링 웹 개발 기초</title><link href="https://ubermen5che.github.io/java/spring/Web-%EC%8A%A4%ED%94%84%EB%A7%81-%EC%9B%B9-%EA%B0%9C%EB%B0%9C-%EA%B8%B0%EC%B4%88/" rel="alternate" type="text/html" title="[Web] 스프링 웹 개발 기초" /><published>2021-07-03T00:00:00+09:00</published><updated>2021-07-03T00:00:00+09:00</updated><id>https://ubermen5che.github.io/java/spring/%5BWeb%5D%20%EC%8A%A4%ED%94%84%EB%A7%81%20%EC%9B%B9%20%EA%B0%9C%EB%B0%9C%20%EA%B8%B0%EC%B4%88</id><content type="html" xml:base="https://ubermen5che.github.io/java/spring/Web-%EC%8A%A4%ED%94%84%EB%A7%81-%EC%9B%B9-%EA%B0%9C%EB%B0%9C-%EA%B8%B0%EC%B4%88/">&lt;h1 id=&quot;web-스프링-웹-개발-기초&quot;&gt;[Web] 스프링 웹 개발 기초&lt;/h1&gt;

&lt;h2 id=&quot;정적-컨텐츠&quot;&gt;정적 컨텐츠&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;간단히 말해서 요청이 들어올 시 서버에서 웹 브라우저에 파일을 전송해주면 웹브라우저는 파일을 받아서 그대로 보여주는 방식&lt;/li&gt;
  &lt;li&gt;스프링에서 정적 컨텐츠는 project에 /static 경로를 찾아서 클라이언트에게 뿌려줌.&lt;/li&gt;
  &lt;li&gt;웹브라우저가 정적 페이지를 요청을 하면, Spring 내장 Tomcat서버를 거쳐 우선 스프링 컨테이너 안에 해당 요청에 관한 컨트롤러가 있는지 우선적으로 확인 후 관련 컨트롤러가 없다면 /static폴더내에 정적 컨텐츠가 존재하는지 확인한다. 있다면 그대로 클라이언트에게 제공해준다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;mvc와-템플릿-엔진&quot;&gt;MVC와 템플릿 엔진&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;MVC : Model, View, Controller&lt;/li&gt;
  &lt;li&gt;예전과 달리 대부분의 웹 개발에서는 MVC패턴을 이용&lt;/li&gt;
  &lt;li&gt;View에는 화면을 그려주는 기능에 집중하고, Controller에서는 비즈니스 로직 및 데이터 처리부분을 담당하고 Model에는 화면구성에 관련된 것들만 모아서 화면에 넘겨줌.&lt;/li&gt;
  &lt;li&gt;PHP, JSP는 템플릿 엔진의 한 종류임&lt;/li&gt;
  &lt;li&gt;템플릿 엔진은 정적 컨텐츠와는 달리 서버에서 HTML을 동적으로 만들어주어 브라우저에 전송함.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;api&quot;&gt;API&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;JSON 포맷으로 클라이언트에 데이터를 전달해주는것&lt;/li&gt;
  &lt;li&gt;최근에 클라이언트는 JSON형식으로 받은 데이터를 사용자에게 보여줌&lt;/li&gt;
  &lt;li&gt;API는 View를 따로 생성하지 않고 @ResponseBody를 이용해서 HTTP body에 객체 정보를 HttpMessageConverter가 적절한 형태(JSON, XML등)으로 변환하여 요청한 상대(browser, Android, server등)에게 데이터를 보내줌.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>YongJun Kwon</name><email>ubermen5ch1308@gmail.com</email></author><category term="Java" /><category term="Spring" /><category term="Java" /><category term="MVC" /><category term="API" /><category term="템플릿 엔진" /><category term="Template engine" /><summary type="html">[Web] 스프링 웹 개발 기초</summary></entry><entry><title type="html">[대외활동] 삼성 SDS 멘토링</title><link href="https://ubermen5che.github.io/%EB%8C%80%EC%99%B8%ED%99%9C%EB%8F%99/%EC%82%BC%EC%84%B1SDS-%EB%9E%9C%EC%84%A0-%EB%A9%98%ED%86%A0%EB%A7%81/" rel="alternate" type="text/html" title="[대외활동] 삼성 SDS 멘토링" /><published>2021-06-29T00:00:00+09:00</published><updated>2021-06-29T00:00:00+09:00</updated><id>https://ubermen5che.github.io/%EB%8C%80%EC%99%B8%ED%99%9C%EB%8F%99/%EC%82%BC%EC%84%B1SDS%20%EB%9E%9C%EC%84%A0%20%EB%A9%98%ED%86%A0%EB%A7%81</id><content type="html" xml:base="https://ubermen5che.github.io/%EB%8C%80%EC%99%B8%ED%99%9C%EB%8F%99/%EC%82%BC%EC%84%B1SDS-%EB%9E%9C%EC%84%A0-%EB%A9%98%ED%86%A0%EB%A7%81/">&lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML&quot;&gt;&lt;/script&gt;

&lt;p&gt;2021년 6월 29일 화요일 운이좋게도 삼성 SDS랜선 멘토링에 참여하게되었습니다. 오늘 강의해주셨던 내용들을 단순 기억에 의존하여 작성한 내용이니 참고해주시면 좋을것 같습니다. 주된내용은 좋은개발이 무엇인지, 개발자에 대한 덕목에 대한 내용입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/2021-06-29/mentoring.png&quot; alt=&quot;mentoring.png&quot; class=&quot;align-center&quot; width=&quot;70%&amp;quot;, height=&amp;quot;70%&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;개발의-시작은-두가지&quot;&gt;개발의 시작은 두가지&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- 다른 사람으로 부터 오는 요구사항을 개발.
- 나의 생각에 따른 개발.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;개발자에게-가장-중요한-덕목&quot;&gt;개발자에게 가장 중요한 덕목&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;개발자는 어떠한 문제가 존재할 때 최적의 방법을 찾아 해결할 수 있는 문제해결능력이 가장 중요하다!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;삼성SDS 시니어 개발자인 박준수 프로님의 사례를 예를들어 설명해보겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;잔여-백신-예약&quot;&gt;잔여 백신 예약&lt;/h3&gt;

&lt;p&gt;현재 수많은 사람들이 잔여 백신 접종 신청을 위해 많은 시간을 모니터를 보며 새로고침을 하고있습니다. 앞으로 개발자가 될 생각이라면? 우리는 이 문제를 프로그래밍을 해서 자동화하는 방법을 찾을 수 있을것입니다. 위에서 개발의 시작은 두가지라고 했습니다. 이 경우 나의 생각에 따른 개발이며, 잔여 백신 접종 신청을 자동화 하는것이 요구사항일 것입니다. 이 사례를 통해 느끼는 바는 우리가 해결해야할 문제는 우리의 일상속 어딘가에 분명히 존재하며, 개발자는 이러한 문제들을 프로그래밍을 통해 어떻게 효율적으로 잘 해결해야할 것인지 항상 고민해야하는 존재라는것으로 받아들였습니다.&lt;/p&gt;

&lt;h3 id=&quot;박준수-프로님의-조언&quot;&gt;박준수 프로님의 조언&lt;/h3&gt;

&lt;p&gt;개발자의 길이 나에게 맞는지 잘 모르겠다면, 이러한 사고에 익숙한지 따져보면 알 수 있을것. 익숙하지 않다면 개발자의 길을 다시한번 심사숙고 해보는것이 좋을것이다.&lt;/p&gt;

&lt;h2 id=&quot;좋은-개발이란&quot;&gt;좋은 개발이란?&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;주어진 요구사항을 잘 분석하여 적절한 개발을 하자!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;1부터 10까지 더해보는 문제를 해결해보고자 합니다. 우리는 이 때 단순히 1+2+3+…+10 방식으로 문제를 해결해 볼 수도 있고 \(sum = \frac{10*(10+1)}{2}\) 수식을 사용하여 좀 더 빠르게 문제를 해결하거나 1~N으로 일반화 하여 문제를 해결해 볼 수 있을것입니다. 우리는 이 때 요구사항에 집중해보는것이 필요합니다. 요구사항에서는 단지 1~10까지 더하라는 요구만 있을뿐이기 때문에 주어진 요구사항에 맞게 적절한 방법을 사용하여 문제를 해결해나가면 되는것입니다.&lt;/p&gt;

&lt;p&gt;(최근 하드웨어가 좋아지면서 때로는 \(O(N^2)\)  복잡도를 가진 알고리즘이 \(O(N)\) 보다 좋아보일때도 있다고합니다. 코드를 누구나 쉽게 보고 이해할 수 있다면 말이죠.)&lt;/p&gt;

&lt;p&gt;처음부터 문제를 일반화하여 거창하고 어렵게 해결할 필요가 없습니다. 요구사항에 한하여 문제를 간단히 생각해보고 필요하다면 일반화하여 개선해나가면 되는것이기 때문입니다. 따라서 요구사항 분석을 철저히 하고 그에 맞는 개발을 하라는것입니다.&lt;/p&gt;

&lt;h2 id=&quot;워라밸에-대하여&quot;&gt;워라밸에 대하여&lt;/h2&gt;

&lt;p&gt;최근 사람들은 워라밸을 중시합니다. 개발자들이 워라밸을 지키기 위해서는 누구나 이해하기 쉬운 깔끔한 코드를 짜야 라이프 밸런스가 보장됩니다. 왜나하면 실무에서는 수많은 사람들과 협업하며 내가 짠 코드를 누군가가 유지보수를 할 수 있는 상황이 오며 이해하기 어려운 코드를 짯다면 빗발치는 연락 때문에 가뭄에 단비와 같은 휴가를 제대로 보낼 수 없겠죠. &lt;strong&gt;따라서 최대한 간결하고 직관적인 코드를 짜야합니다.&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;어떤-기술스택-언어를-습득해야할까요&quot;&gt;어떤 기술스택, 언어를 습득해야할까요?&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;현재 가장 익숙한 언어를 사용하는것이 좋을것이다. 해당 언어를 마스터했다면 다른 언어를 공부해봐도 좋다. 다른 언어를 공부할 때는 내가 익숙한 언어와의 차이점이 무엇인지에 대해 생각해보면서 학습해보면 좋을것입니다.&lt;/li&gt;
  &lt;li&gt;주로쓰던 언어를 마스터하였다면 트렌드에 맞는 언어를 선택해서 학습해봅시다.&lt;/li&gt;
  &lt;li&gt;어떤 기술스택을 쓰던 내게 주어진 문제를 해결할 수 있는것이면 됩니다.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>YongJun Kwon</name><email>ubermen5ch1308@gmail.com</email></author><category term="대외활동" /><category term="삼성SDS" /><category term="멘토링" /><category term="프로그래머" /><category term="개발자" /><summary type="html"></summary></entry><entry><title type="html">자바 기초 정리</title><link href="https://ubermen5che.github.io/java/Java-%EA%B8%B0%EC%B4%88-%EC%A0%95%EB%A6%AC/" rel="alternate" type="text/html" title="자바 기초 정리" /><published>2021-06-28T00:00:00+09:00</published><updated>2021-06-28T00:00:00+09:00</updated><id>https://ubermen5che.github.io/java/Java%20%EA%B8%B0%EC%B4%88%20%EC%A0%95%EB%A6%AC</id><content type="html" xml:base="https://ubermen5che.github.io/java/Java-%EA%B8%B0%EC%B4%88-%EC%A0%95%EB%A6%AC/">&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Local variable: method내에 정의된 변수. local이라고 이름이 붙혀진 이유는 함수 정의 안에서 한정되기 때문이다. 두 메소드가 존재한다고 가정했을 때, 서로 다른 메소드 내에 같은 변수이름이 존재해도 상관없다. 그리고 둘중 하나의 변수명을 변경했다고 해서 다른 변수에 전혀 영향을 주지 않는다.(지역적)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Object(instance of the class): 클래스의 오브젝트 또는 클래스의 인스턴스라고도 불려진다. 오브젝트는 어떠한 정보를 저장하는 변수와, action을 담당하는 method로 이루어져있다. 흔히 클래스는 붕어빵틀에 비유되고 오브젝트는 붕어빵에 대응된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Instance Variables: 클래스내에 정의된 변수들에 해당된다. 예는 다음과 같다.&lt;/p&gt;

    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;n&quot;&gt;date&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;month&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;June&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;date&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;day&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;25&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;date&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;year&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2021&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Call-by-value: Java에서 method의 parameter로 primitive type을 전달할 때는 Call-by-value형식으로 값이 전달된다. 간단하게 생각하면 값이 그대로 복사되어 호출된 method에 전달된다. 즉 parameter로 전달된 값은 그저 변수에 복사된 값이고 변수의 주소가 전달된다는 뜻이 아니라는것이다. Class Type을 parameter로 전달할 때는 Call-by-value와는 다른 방식으로 전달된다. 그러나 String의 경우는 primitive type과 동일하게 파라미터가 전달된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;this parameter: method definition안에서 calling object의 이름을 this parameter로 대체할 수 있다. ex) date.month == this.month&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;this parameter는 instance variables와 parameter을 구분하는데 유용하게 사용된다&lt;/p&gt;

    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;setDate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;month&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;day&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;year&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  	&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;month&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;monthString&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;month&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  	&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;day&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;day&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  	&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;year&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;year&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;만약 this를 사용하지 않았다면 day = day에서 identifier와 parameter를 구분할 수 없다. 컴파일은 정상적으로 이루어질지 몰라도 우리가 원하는 결과를 얻지못한다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Java에서 오브젝트를 담는 배열의 경우 각 배열에는 오브젝트를 가리키는 주소값만 저장된다. 따라서 객체 배열에 객체를 담을때는 생성자를 사용해서 담아주어야한다.&lt;/p&gt;

    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Hashing&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Slot&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hashtable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

      &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Hashing&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hashtable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Slot&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Slot&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;nc&quot;&gt;Slot&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;nc&quot;&gt;Slot&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hashTable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Slot&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;hashTable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Slot&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;test&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>YongJun Kwon</name><email>ubermen5ch1308@gmail.com</email></author><category term="Java" /><category term="Java" /><summary type="html">Local variable: method내에 정의된 변수. local이라고 이름이 붙혀진 이유는 함수 정의 안에서 한정되기 때문이다. 두 메소드가 존재한다고 가정했을 때, 서로 다른 메소드 내에 같은 변수이름이 존재해도 상관없다. 그리고 둘중 하나의 변수명을 변경했다고 해서 다른 변수에 전혀 영향을 주지 않는다.(지역적)</summary></entry><entry><title type="html">Linear algebra Vector</title><link href="https://ubermen5che.github.io/Linear-algebra-Vector/" rel="alternate" type="text/html" title="Linear algebra Vector" /><published>2021-06-21T00:00:00+09:00</published><updated>2021-06-21T00:00:00+09:00</updated><id>https://ubermen5che.github.io/Linear%20algebra-Vector</id><content type="html" xml:base="https://ubermen5che.github.io/Linear-algebra-Vector/">&lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML&quot;&gt;&lt;/script&gt;

&lt;h1 id=&quot;선형대수-기본-벡터&quot;&gt;선형대수 기본 벡터&lt;/h1&gt;

&lt;h1 id=&quot;linear-algebra---essence-of-linear-algebravector&quot;&gt;Linear Algebra - Essence of linear algebra(Vector)&lt;/h1&gt;

&lt;h2 id=&quot;벡터-개념의-필요성&quot;&gt;벡터 개념의 필요성&lt;/h2&gt;

&lt;p&gt;최근 정보검색, 데이터과학기초(Fundementals of data science)과목을 수강하면서 벡터의 중요성을 깨닫게 되었습니다. 정보검색에서 document와 query의 similarity를 측정하기 위해 벡터가 필요하였고, 데이터과학기초에서는 Supervised learning 범주에 속하는 SVM(Support Vector Machine)에서 벡터 개념이 필요하였습니다. 지난학기 벡터 개념이 제대로 정립이 되어있지 않아 공부하는데 어려움이 있었던 경험을 계기로 이번 포스팅을 작성하게되었습니다.&lt;/p&gt;

&lt;p&gt;출저를 먼저 밝히자면 유튜브 Blue1Brown 채널의 선형대수 시리즈 영상을 보며 정리했음을 알립니다.&lt;/p&gt;

&lt;h2 id=&quot;벡터-개요&quot;&gt;벡터 개요&lt;/h2&gt;

&lt;p&gt;기본적으로 선형 대수의 구성요소는 벡터입니다. 따라서 선형대수의 기본 구성요소인 벡터에 대해 명확히 알고가는것은 중요한 일 일것입니다.&lt;/p&gt;

&lt;p&gt;벡터는 물리학, 수학, CS분야에서 뜻하는바가 조금씩 다릅니다. 이번 포스팅에서는 CS분야에 사용되는 벡터에 대해 중점적으로 기술하겠습니다.&lt;/p&gt;

&lt;p&gt;CS관점에서 Vector가 의미하는 바는 순차 숫자 리스트입니다. 예를들어 한화를 기준으로 비트코인에 대한 정보를 2차원(길이가 2인) 벡터로 모델링 해본다면 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;1은 비트코인의 수량을 뜻합니다. 즉 비트코인 1개당 4500만원이라는 정보를 모델링 하고 있는것 입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/2021-06-21/bitcoin.png&quot; alt=&quot;bitcoin.png&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

\[\begin{bmatrix}1 \\45,000,000\end{bmatrix}\]

&lt;p&gt;우리는 기하학 관점에서 벡터를 원점에 뿌리를 둔 화살표라고 생각하면 벡터를 이해하기 수월할 것 입니다. 이는 벡터는 원점이 아닌 다른 좌표에 벡터를 표시할 수 있는 물리학 관점과 달리 선형대수학에서는 기본적으로 벡터는 원점에 뿌리를 둔 벡터라고 생각하면 이해하기 편합니다. CS관점에서 우리는 숫자-리스트라는 관점으로 벡터를 이해 해보려고 합니다. 숫자리스트는 곧 벡터의 좌표를 의미합니다.&lt;/p&gt;

&lt;p&gt;벡터의 좌표는 숫자쌍입니다. 이 숫자쌍은 꼬리(원점)에서 시작한 벡터가 끝에 어떻게 다다를지 알려줍니다. 첫 번째 숫자는 원점을 기준으로 x축을 따라 얼마나 떨어졌는지가에 대한 정보를 포함하고 양수면 오른쪽, 음수면 왼쪽을 의미합니다. 마찬가지로 두번 째 숫자의 경우 y축에 대한 좌표 정보를 가집니다. 마찬가지로 양수이면 위쪽 음수이면 아래쪽을 의미하게됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/2021-06-21/vector1.png&quot; alt=&quot;vector1.png&quot; class=&quot;align-center&quot; width=&quot;50%&amp;quot;, height=&amp;quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림에서 첫번째 원소(-2)는 x축에 평행하면서 -2만큼 이동하라는 의미이고, 두번째 원소(4)는 y축과 평행하여 4만큼 이동하라는 뜻입니다. 이는 3차원,4차원…n차원으로 확장가능한 개념이며, 3차원까지는 우리가 간단하게 시각화를 할 수 있지만 그 이상의 차원은 상상해보기가 힘듭니다.&lt;/p&gt;

\[\begin{bmatrix}2\\3\\5\end{bmatrix},\begin{bmatrix}2\\3\\5\\7\end{bmatrix} ...\]

&lt;h2 id=&quot;벡터의-연산&quot;&gt;벡터의 연산&lt;/h2&gt;

&lt;h3 id=&quot;벡터의-합&quot;&gt;벡터의 합&lt;/h3&gt;

&lt;p&gt;결국 선형대수의 모든 주제는 덧셈과, 곱셈 두가지 연산을 중심으로 일어납니다. 덧셈에 대해 먼저 논해보자면 아래와 그림과 같이 두 벡터가 있다고 가정해봅시다. 벡터v는 오른쪽 위쪽을 향한 벡터이고 벡터w는 오른쪽 아랫방향을 가리키고 있습니다. 이 두 벡터를 더하는 행위는 한 벡터의 꼬리를 다른 벡터의 끝으로 옮기는것을 말합니다.&lt;/p&gt;

&lt;p&gt;그리고나서 벡터v의 꼬리부분에서 옮겨진 벡터w의 끝을 가리키는 새 벡터를 그리면 바로 이 새 벡터가 두 벡터의 합을 나타냅니다. 흥미로운 부분은 선형대수에서 유일하게 벡터를 원점으로부터 멀리 이탈시키는 순간이라는 점입니다.&lt;/p&gt;

\[\]

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/2021-06-21/vector_sum.png&quot; alt=&quot;vector_sum.png&quot; class=&quot;align-center&quot; width=&quot;50%&amp;quot;, height=&amp;quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;벡터의 덧셈을 좀 더 간단히 생각해보면 아래 그림과 같이 생각해볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/2021-06-21/vector_sum_2.png&quot; alt=&quot;vector_sum_2.png&quot; class=&quot;align-center&quot; width=&quot;50%&amp;quot;, height=&amp;quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;단순히 벡터의 합을 각 벡터의 원소에 대응하는 숫자의 합이라고 생각하면 이해하기 쉽습니다. 즉 두 벡터의 합으로 생성된 새 벡터는 두 벡터의 x좌표 정보를 나타내는 원소의 합(2+3=5) y좌표 정보를 나타내는 원소들의 합(3+(-2))로 새 벡터를 나타낼 수 있습니다. 원점을 기준으로 x축의 방향 5칸 이동, y축의 방향으로 1칸이동한 위치에 점을 찍고 화살표를 그림으로 써 동일한 결과를 얻을 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;벡터의-곱스칼라-곱&quot;&gt;벡터의 곱(스칼라 곱)&lt;/h3&gt;

&lt;p&gt;벡터의 곱은 합보다 더욱 간단합니다.&lt;/p&gt;

\[2*\begin{bmatrix}2\\3\end{bmatrix}=\begin{bmatrix}4\\6\end{bmatrix}\]

&lt;p&gt;어떤 벡터의 각 원소에 Scalar(Number)를 곱하면 그것이 곧 벡터의 곱이됩니다. 기하학적으로 생각하면 벡터를 Scalar만큼 늘리거나 줄이는 것에 해당합니다. 벡터를 늘리는 연산은 위와같이 분수가 아닌 정수 형태의 곱으로 나타나고 줄이는 연산은 분수형태의 Scalar가 곱해지게됩니다. 음수의 경우도 생각해 보아야하는데요, 음수의 경우는 벡터의 방향을 현재 벡터의 정 반대의 방향을 가지는 벡터로 변환하는 기능을 합니다. 아래의 벡터의 스칼라 곱 연산을 시각화 해본 그림입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/posts/2021-06-21/vector_scalar.png&quot; alt=&quot;vector_scalar.png&quot; class=&quot;align-center&quot; width=&quot;70%&amp;quot;, height=&amp;quot;70%&quot; /&gt;&lt;/p&gt;</content><author><name>YongJun Kwon</name><email>ubermen5ch1308@gmail.com</email></author><summary type="html"></summary></entry><entry><title type="html">Logic and Computer Science - 논리학 기초 - Statements</title><link href="https://ubermen5che.github.io/logic/computer%20science/Logic-and-Computer-Science-Logic-Statements/" rel="alternate" type="text/html" title="Logic and Computer Science - 논리학 기초 - Statements" /><published>2021-01-23T00:00:00+09:00</published><updated>2021-01-23T00:00:00+09:00</updated><id>https://ubermen5che.github.io/logic/computer%20science/Logic%20and%20Computer%20Science-Logic-Statements</id><content type="html" xml:base="https://ubermen5che.github.io/logic/computer%20science/Logic-and-Computer-Science-Logic-Statements/">&lt;h3 id=&quot;what-is-an-statements&quot;&gt;What is an statements?&lt;/h3&gt;
&lt;p&gt;statements는 참 또는 참일 가능성이 있는 문장이다. statements를 만들때 어떤 참또는 거짓을 보일 수 있는 문장을 만들어야한다.&lt;/p&gt;

&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;모든 한국시민들은 한국에 살고 있다.&lt;/li&gt;
    &lt;li&gt;서울에 있는 모든 기업들은 사무실에서 레드 카펫을 사용하고있다.&lt;/li&gt;
    &lt;li&gt;애플은 마이크로소프트보다 더 많은 자본을 가지고 있다.&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;위의 예를 잘 살펴보면, 각 statements는 참을 나타내려고 시도하고 있는 것처럼 보인다. 물론 첫 번쨰, 두 번째 문장들이 거짓이고 세 번째 문장은 참이지만 논리학의 관점에서 보았을 때, 각 문장들은 statement로서 자격을 갖추었다. 왜냐하면 참일 가능성이 있는 문장을 나타내고 있기 때문이다.&lt;/p&gt;

&lt;p&gt;영어에서는 이러한 문장들을 “declarative”하다고불린다. 논리학에서는 오직 declaratives만이 statements의 자격을 가진다. 아래의 다양한 종류의 문장들이 있는데, 이 문장들을 비교하고 대조해보자.&lt;/p&gt;

&lt;blockquote&gt;

  &lt;ol&gt;
    &lt;li&gt;Question or “interrogative” - What time is it?&lt;/li&gt;
    &lt;li&gt;Commands or “imperative” - Close the door!&lt;/li&gt;
    &lt;li&gt;Exclamations or “exclamatory” - Ouch!&lt;/li&gt;
    &lt;li&gt;Performatives - “I promise,” “I thee wed”&lt;/li&gt;
    &lt;li&gt;Declarative - “Carbon is an element”&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;1,2,3,4와 같은 종류의 문장의 경우 참 또는 거짓을 논할 수 없는 문장이다. 따라서 오직 5번과 같은 종류의 문장만 statements라고 말할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;simple-and-compound-statements&quot;&gt;Simple and Compound statements&lt;/h3&gt;

&lt;p&gt;오직 하나의 진실만을 공표하는 statement를 &lt;strong&gt;simple statement&lt;/strong&gt;라고 한다.&lt;/p&gt;
&lt;blockquote&gt;

  &lt;p&gt;Ann is home&lt;/p&gt;

  &lt;p&gt;Bob is home&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이러한 문장들은 각각 어떤 것이 참인지 그리고 어떤 사건에 대한 오직 하나의 상황 또는 상태가 참인지 볼 수 있다. 논리적인 arguments를 작성할 때, 나의 전제들을 내가 분해할 수 있을 만큼 simple statements로 분해하는 것은 좋은 연습이 될 수 있다. 이 연습이 나의 argument에 statements에 대한 진리를 결정하는데 도움을 줄 수 있다.&lt;/p&gt;

&lt;p&gt;만약 내 전제에서 하나 이상의 진리를 선언하고 싶다면 어떻게 할 것인가? 이 경우 &lt;strong&gt;statment operator&lt;/strong&gt;를 사용하여 두개이상의 simple statments를
합칠 수 있다. statement operator는 simple statements를 연결하여 &lt;strong&gt;compound statment&lt;/strong&gt;를 만들어준다. 예를 들어,&lt;/p&gt;

&lt;blockquote&gt;

  &lt;p&gt;Ann is hime AND Bob is home&lt;/p&gt;

  &lt;p&gt;The screen door has a hole in it OR I’m seeing things&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;위의 각 문장에서, AND, OR에 의해 합쳐진 두개의 simple statments 볼 수 있다. 이러한 연산자들은 simple statments를 사용하여 하나 이상의 진리를 선언하도록 허용해준다. 추후에 이루어질 포스팅에서는 다양한 연산자들을 알아볼 것이다.&lt;/p&gt;

&lt;p class=&quot;notice--primary&quot;&gt;&lt;strong&gt;Primary Notice:&lt;/strong&gt; Logic and Computer Science 시리즈는 마이크로소프트에서 제공하는 강좌를 토대로 내용을 정리하여 작성되었음을 알려드립니다.&lt;/p&gt;</content><author><name>YongJun Kwon</name><email>ubermen5ch1308@gmail.com</email></author><category term="Logic" /><category term="Computer Science" /><category term="Logic" /><category term="Computer Science" /><category term="논리" /><category term="컴퓨터과학" /><summary type="html">What is an statements? statements는 참 또는 참일 가능성이 있는 문장이다. statements를 만들때 어떤 참또는 거짓을 보일 수 있는 문장을 만들어야한다.</summary></entry><entry><title type="html">Logic and Computer Science - 논리학 기초 - 논쟁(argument)</title><link href="https://ubermen5che.github.io/logic/computer%20science/Logic-and-Computer-Science-Logic-Arguments/" rel="alternate" type="text/html" title="Logic and Computer Science - 논리학 기초 - 논쟁(argument)" /><published>2021-01-06T00:00:00+09:00</published><updated>2021-01-06T00:00:00+09:00</updated><id>https://ubermen5che.github.io/logic/computer%20science/Logic%20and%20Computer%20Science-Logic-Arguments</id><content type="html" xml:base="https://ubermen5che.github.io/logic/computer%20science/Logic-and-Computer-Science-Logic-Arguments/">&lt;h3 id=&quot;what-is-an-arguments&quot;&gt;What is an arguments?&lt;/h3&gt;
&lt;p&gt;이전 포스팅에서 논리학은 적절하게 정리된 생각에 관한 과학이라고 했다. 모든과학분야에서 해당 연구분야에 대한 초점과 목표를 가지는데, 논리학에서의 목표는 논쟁이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;논쟁은 우리의 생각을 구조화하는 방법이다&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;우리는 가끔 말싸움을 하며 논쟁을 벌이기도 한다. 만약 친구, 동료, 가족들과 논쟁을 벌이는거라면 어떤일에 대해 논쟁의 대상자의 의견에 동의하지않거나 본인이 주장하는 의견과 거리가 멀어서 일어날 것이다.&lt;/p&gt;

&lt;p&gt;이러한 일생생활에서 발생하는 논쟁이 매우 논리적일수도 있겠지만, 단지 소리만 지르며 끝나는 논쟁이라고 한다면 이는 논리학과는 거리가 멀다. 논리학에서 논쟁은 더욱더 구체적인 목적을 가지고 정형화된 구조를 가진다.&lt;/p&gt;

&lt;p&gt;특히 논쟁은 누군가를 설득시키기 위해 고안된 체계적인 문장들의 집합이다. 그 구조는 매우 중요하다. 논리학자들은 구조를 더욱 명확히 정의하기 위해 논쟁을 구성하는 몇몇의 요소에 이름을 부여했다. 교과서 적인 논쟁의 정의를 나열해보자면 다음과 같다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;dl&gt;
    &lt;dt&gt;논쟁(arguments)&lt;/dt&gt;
    &lt;dd&gt;논쟁은 주장(결론이라 불리우는)에 힘을 실어주는 이유(전제)들로 구성되어있다.&lt;/dd&gt;
  &lt;/dl&gt;
&lt;/blockquote&gt;

&lt;p&gt;위의 정의를 볼 때 2개의 구성요소를 확인할 수 있을 것이다. 그러나 실제로 논쟁은 3개의 중요한 요소로 구성되어있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;전제(Premises): 인용된 이유 또는 증거&lt;/li&gt;
  &lt;li&gt;결론(Conclusion): 전제에 의해 증명되고있는 진술(statement)&lt;/li&gt;
  &lt;li&gt;논리적 관계(A logical relation): 결론와 결론의 논리적 연결.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;우리가 논쟁을 할 때, A라는 사람이 B라는 사람에게 자신의 주장을 펼쳤다고 한다면, B는 A의 의견을 들어야 하며, 그 전제로부터 결론을 이끌어내야 한다. A가 주장한 전제는 결론이 충분히 참이라는것을 동의하도록 B를 설득시킬 수 있어야 한다.&lt;/p&gt;

&lt;p&gt;다음의 예제를 보며 논쟁에서 논리적 관계에 중요성에 대해 살펴보도록 하자.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;전제1: 팀쿡은 애플의 CEO이다.&lt;/li&gt;
  &lt;li&gt;전제2: 잔디밭에 있는 풀들의 색은 초록색이다.&lt;/li&gt;
  &lt;li&gt;결론: 그러므로 내일 아침에도 해가 뜰것이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위의 예제를 볼 때, 2개의 전제 및 결론을 가진다. 이는 논쟁의 3가지 구성요소를 가지는것을 볼 수 있다. 그러나 이 전제들은 비록 전제들이 모두 참일지라도 결론을 결코 뒷받침해주지 않고 결론이 참인것을 신뢰하도록 하는 근거가 되지못한다.&lt;/p&gt;

&lt;p&gt;또 다른 예시를 봐보자.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;전제1: 모든 나무들은 식물이다.&lt;/li&gt;
  &lt;li&gt;전제2: 소나무는 나무이다.&lt;/li&gt;
  &lt;li&gt;결론: 그러므로 소나무는 식물이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위의 예시는 논쟁의 구성요소를 모두 갖추었다. 첫번째 예시와는 달리 논리적 관계또한 올바르게 설정되어있는것을 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;정리해보자면 논쟁은 전제, 결론, 논리적 관계의 요소를 포함하며, 논쟁은 누군가를 설득시키기 위해 고안된 체계적인 문장들의 집합이므로 나의 주장을 상대방에게 펼칠 때 결론을 충분히 뒷받침해줄만한 적절한 근거를 제시해야하며, 결론과 전제가 충분히 논리적 관계를 형성하는지 따져봐야한다는것이다.&lt;/p&gt;

&lt;p class=&quot;notice--primary&quot;&gt;&lt;strong&gt;Primary Notice:&lt;/strong&gt; Logic and Computer Science 시리즈는 마이크로소프트에서 제공하는 강좌를 토대로 내용을 정리하여 작성되었음을 알려드립니다.&lt;/p&gt;</content><author><name>YongJun Kwon</name><email>ubermen5ch1308@gmail.com</email></author><category term="Logic" /><category term="Computer Science" /><category term="Logic" /><category term="Computer Science" /><category term="논리" /><category term="컴퓨터과학" /><summary type="html">What is an arguments? 이전 포스팅에서 논리학은 적절하게 정리된 생각에 관한 과학이라고 했다. 모든과학분야에서 해당 연구분야에 대한 초점과 목표를 가지는데, 논리학에서의 목표는 논쟁이다.</summary></entry></feed>